// node_modules/mdatools/stat/index.js
function getPValue(pfun, crit, tail, params = []) {
  if (tail === "left") {
    return pfun(crit, ...params);
  }
  if (tail === "right") {
    return 1 - pfun(crit, ...params);
  }
  if (tail === "both") {
    let p = pfun(crit, ...params);
    return min([p, 1 - p]) * 2;
  }
}
function tTest1(x, mu = 0, alpha = 0.05, tail = "both") {
  if (typeof mu !== "number") {
    throw Error("Parameter 'mu' should be a number.");
  }
  const nx = x.length;
  const effectExpected = mu;
  const effectObserved = mean(x);
  const se = sd(x) / Math.sqrt(nx);
  const tValue = (effectObserved - effectExpected) / se;
  const DoF = nx - 1;
  const errMargin = qt(1 - alpha / 2, DoF) * se;
  return {
    test: "One sample t-test",
    effectExpected: mu,
    effectObserved,
    se,
    tValue,
    alpha,
    tail,
    DoF,
    pValue: getPValue(pt, tValue, tail, [DoF]),
    ci: [effectObserved - errMargin, effectObserved + errMargin]
  };
}
function tTest2(x, y, alpha = 0.05, tail = "both") {
  const nx = x.length;
  const mx = mean(x);
  const my = mean(y);
  const ny = y.length;
  const effectExpected = 0;
  const effectObserved = mx - my;
  const se = Math.sqrt(sd(x) ** 2 / nx + sd(y) ** 2 / ny);
  const tValue = (effectObserved - effectExpected) / se;
  const DoF = nx - 1 + (ny - 1);
  const errMargin = qt(1 - alpha / 2, DoF) * se;
  return {
    test: "Two sample t-test",
    effectExpected,
    effectObserved,
    se,
    tValue,
    alpha,
    tail,
    DoF,
    pValue: getPValue(pt, tValue, tail, [DoF]),
    ci: [effectObserved - errMargin, effectObserved + errMargin]
  };
}
function kurtosis(x) {
  let n = x.length;
  let m = mean(x);
  let m4 = 0;
  let m2 = 0;
  for (let i = 0; i < n; i++) {
    m2 = m2 + Math.pow(x[i] - m, 2);
    m4 = m4 + Math.pow(x[i] - m, 4);
  }
  return m4 / n / Math.pow(m2 / n, 2);
}
function skewness(x) {
  let n = x.length;
  let m = mean(x);
  let m3 = 0;
  let m2 = 0;
  for (let i = 0; i < n; i++) {
    m2 = m2 + Math.pow(x[i] - m, 2);
    m3 = m3 + Math.pow(x[i] - m, 3);
  }
  return m3 / n / Math.pow(m2 / n, 1.5);
}
function min(x) {
  let n = x.length;
  let min2 = Number.POSITIVE_INFINITY;
  while (n--)
    min2 = x[n] < min2 ? x[n] : min2;
  return min2;
}
function max(x) {
  let n = x.length;
  let max2 = Number.NEGATIVE_INFINITY;
  while (n--)
    max2 = x[n] > max2 ? x[n] : max2;
  return max2;
}
function sum(x) {
  let s = 0;
  for (let i = 0; i < x.length; i++) {
    s = s + x[i];
  }
  return s;
}
function prod(x) {
  let p = 1;
  for (let i = 0; i < x.length; i++) {
    p = p * x[i];
  }
  return p;
}
function mean(x) {
  return sum(x) / x.length;
}
function cov(x, y, biased = false, mx = void 0, my = void 0) {
  const n = x.length;
  if (y.length !== n) {
    throw Error("Vectors 'x' and 'y' must have the same length.");
  }
  if (n < 2) {
    throw Error("Vectors 'x' and 'y' must have at least two values.");
  }
  if (mx === void 0)
    mx = mean(x);
  if (my === void 0)
    my = mean(y);
  let cov2 = 0;
  for (let i = 0; i < n; i++) {
    cov2 = cov2 + (x[i] - mx) * (y[i] - my);
  }
  return cov2 / (biased ? n : n - 1);
}
function variance(x, biased = false, m = void 0) {
  return cov(x, x, biased, m, m);
}
function sd(x, biased = false, m = void 0) {
  return Math.sqrt(variance(x, biased, m));
}
function cor(x, y, method = "pearson") {
  if (method === "spearman") {
    return cor(rank(x), rank(y));
  }
  return cov(x, y) / (sd(x) * sd(y));
}
function quantile(x, p) {
  x = sort(x);
  const n = x.length;
  if (!Array.isArray(p))
    p = [p];
  if (typeof p[0] !== "number" || min(p) < 0 || max(p) > 1) {
    throw new Error("Parameter 'p' must be between 0 and 1 (both included).");
  }
  function q(x2, p2) {
    const h = (n - 1) * p2 + 1;
    const n1 = Math.floor(h);
    const n2 = Math.ceil(h);
    return x2[n1 - 1] + (x2[n2 - 1] - x2[n1 - 1]) * (h - Math.floor(h));
  }
  const out = p.map((v) => q(x, v));
  return p.length == 1 ? out[0] : out;
}
function seq(min2, max2, n) {
  if (n < 2) {
    throw new Error("Parameter 'n' should be \u2265 2.");
  }
  if (n === void 0 && Number.isInteger(min2) && Number.isInteger(max2)) {
    if (max2 === min2)
      return [max2];
    n = max2 - min2 + 1;
  }
  const step = (max2 - min2 + 0) / (n - 1 + 0);
  let out = [...Array(n)].map((x, i) => min2 + i * step);
  if (Math.abs(step) < 1) {
    const r = Math.pow(10, Math.round(-Math.log10(step)) + 1);
    out = out.map((v) => Math.round((v + Number.EPSILON) * r) / r);
  }
  return out;
}
function range(x) {
  return [min(x), max(x)];
}
function mrange(x, margin = 0.05) {
  const mn = min(x);
  const mx = max(x);
  const d = mx - mn;
  return [mn - d * margin, max(x) + d * margin];
}
function split(x, n) {
  if (x === void 0 || !Array.isArray(x) || x.length < 2) {
    throw new Error("split: 'x' must bet a vector with numbers.");
  }
  if (n === void 0 || n < 2) {
    throw new Erro("split: 'n' must be a positive integer number.");
  }
  const mn = min(x);
  const mx = max(x);
  if (mn === mx) {
    throw new Error("split: values in a vector 'x' should vary.");
  }
  const step = (mx - mn) / n;
  return Array.from({ length: n + 1 }, (v, i) => mn + i * step + 0);
}
function count(x, bins) {
  if (x === void 0 || !Array.isArray(x) || x.length < 2) {
    throw new Error("count: 'x' must be a vector with numbers.");
  }
  if (bins === void 0 || !Array.isArray(bins) || bins.length < 2) {
    throw new Error("count: 'bins' must be a vector with numbers.");
  }
  const n = bins.length;
  bins[n - 1] = bins[n - 1] * 1.0001;
  let counts = Array(n - 1).fill(0);
  for (let i = 0; i < x.length; i++) {
    for (let j = 0; j < n - 1; j++) {
      if (x[i] >= bins[j] && x[i] < bins[j + 1])
        counts[j] = counts[j] + 1;
    }
  }
  return counts;
}
function mids(x) {
  return x.slice(1).map((v, i) => 0.5 * (v + x[i]));
}
function diff(x) {
  return x.slice(1).map((y, i) => y - x[i]);
}
function getOutliers(x, Q1 = void 0, Q3 = void 0) {
  if (Q1 === void 0)
    Q1 = quantile(x, 0.25);
  if (Q3 === void 0)
    Q3 = quantile(x, 0.75);
  const IQR = Q3 - Q1;
  const bl = Q1 - 1.5 * IQR;
  const bu = Q3 + 1.5 * IQR;
  return x.filter((v) => v < bl || v > bu);
}
function rank(x) {
  const y = [...x].sort((a, b) => a - b);
  return x.map((v) => y.indexOf(v) + 1);
}
function ppoints(n) {
  const a = n < 10 ? 3 / 8 : 0.5;
  return Array.from({ length: n }, (v, i) => (i + 1 - a) / (n + (1 - a) - a));
}
function cumsum(x) {
  let s = 0;
  return x.map((v) => s += v);
}
function runif(n, a = 0, b = 1) {
  let out = Array(n);
  for (let i = 0; i < n; i++)
    out[i] = a + Math.random() * (b - a);
  return out;
}
function dunif(x, a = 0, b = 1) {
  if (!Array.isArray(x))
    x = [x];
  const n = x.length;
  const A = 1 / (b - a);
  let d = Array(n);
  for (let i = 0; i < n; i++) {
    d[i] = x[i] < a || x[i] > b ? 0 : A;
  }
  return d;
}
function punif(x, a = 0, b = 1) {
  if (!Array.isArray(x))
    x = [x];
  const n = x.length;
  let p = Array(n);
  for (let i = 0; i < n; i++) {
    if (x[i] < a) {
      p[i] = 0;
    } else if (x[i] > b) {
      p[i] = 1;
    } else {
      p[i] = (x[i] - a) / (b - a);
    }
  }
  return p;
}
function rnorm(n, mu = 0, sigma = 1) {
  let out = Array(n);
  for (let i = 0; i < n; i++) {
    const a = Math.sqrt(-2 * Math.log(Math.random()));
    const b = 2 * Math.PI * Math.random();
    out[i] = a * Math.sin(b) * sigma + mu;
  }
  return out;
}
function dnorm(x, mu = 0, sigma = 1) {
  if (!Array.isArray(x))
    x = [x];
  const n = x.length;
  const A = 1 / (Math.sqrt(2 * Math.PI) * sigma);
  const frac = -0.5 / sigma ** 2;
  let d = Array(n);
  for (let i = 0; i < n; i++) {
    const df2 = x[i] - mu;
    d[i] = A * Math.exp(frac * df2 * df2);
  }
  return x.length === 1 ? d[0] : d;
}
function pnorm(x, mu = 0, sigma = 1) {
  if (!Array.isArray(x))
    x = [x];
  const n = x.length;
  const frac = 1 / (Math.sqrt(2) * sigma);
  let p = Array(n);
  for (let i = 0; i < n; i++) {
    p[i] = 0.5 * (1 + erf((x[i] - mu) * frac));
  }
  return p.length === 1 ? p[0] : p;
}
function qnorm(p, mu = 0, sigma = 1) {
  if (Array.isArray(p)) {
    return p.map((v) => qnorm(v, mu, sigma));
  }
  if (mu !== 0 || sigma !== 1) {
    return qnorm(p) * sigma + mu;
  }
  if (p < 0 || p > 1) {
    throw Error("Parameter 'p' must be between 0 and 1.");
  }
  if (p < 1e-10)
    return -Infinity;
  if (p > 0.9999999999)
    return Infinity;
  const SP1 = 0.425;
  const SP2 = 5;
  const C1 = 0.180625;
  const C2 = 1.6;
  const a0 = 3.3871327179;
  const a1 = 5.0434271938 * 10;
  const a2 = 1.5929113202 * 100;
  const a3 = 5.910937472 * 10;
  const b1 = 1.7895169469 * 10;
  const b2 = 7.8757757664 * 10;
  const b3 = 6.71875636 * 10;
  const c0 = 1.4234372777;
  const c1 = 2.75681539;
  const c2 = 1.3067284816;
  const c3 = 1.7023821103 * 0.1;
  const d1 = 7.370016425 * 0.1;
  const d2 = 1.2021132975 * 0.1;
  const e0 = 6.657905115;
  const e1 = 3.081226386;
  const e2 = 4.2868294337 * 0.1;
  const e3 = 1.7337203997 * 0.01;
  const f1 = 2.4197894225 * 0.1;
  const f2 = 1.2258202635 * 0.01;
  const q = p - 0.5;
  let r;
  if (Math.abs(q) <= SP1) {
    r = C1 - q * q;
    return q * (((a3 * r + a2) * r + a1) * r + a0) / (((b3 * r + b2) * r + b1) * r + 1);
  }
  r = q < 0 ? p : 1 - p;
  r = Math.sqrt(-Math.log(r));
  let res;
  if (r <= SP2) {
    r = r - C2;
    res = (((c3 * r + c2) * r + c1) * r + c0) / ((d2 * r + d1) * r + 1);
  } else {
    r = r - SP2;
    res = ((e3 * r + e2) * r + e1 + e0) / ((f2 * r + f1) * r + 1);
  }
  return q < 0 ? -res : res;
}
function dt(t, dof) {
  if (dof < 0) {
    throw new Error("Parameter 'dof' should be a positive number.");
  }
  if (Array.isArray(t)) {
    return t.map((v) => dt(v, dof));
  }
  const pow = -0.5 * (dof + 1);
  const A = 1 / (Math.sqrt(dof) * beta(0.5, dof / 2));
  return A * Math.pow(1 + t * t / dof, pow);
}
function pt(t, dof) {
  if (dof === void 0 || dof === null || dof < 1) {
    throw Error("Parameter 'dof' (degrees of freedom) must be an integer number >= 1.");
  }
  if (Array.isArray(t)) {
    return t.map((v) => pt(v, dof));
  }
  if (t === 0)
    return 0.5;
  if (t === -Infinity)
    return 0;
  if (t === Infinity)
    return 1;
  if (t > 0)
    return 1 - pt(-t, dof);
  return integrate((x) => dt(x, dof), -Infinity, t);
}
function qt(p, dof) {
  if (dof === void 0 || dof === null || dof < 1) {
    throw Error("Parameter 'dof' (degrees of freedom) must be an integer number >= 1.");
  }
  if (p < 0 || p > 1) {
    throw Error("Parameter 'p' must be between 0 and 1.");
  }
  if (Array.isArray(p)) {
    return p.map((v) => qt(v, dof));
  }
  if (p < 1e-10)
    return -Infinity;
  if (p > 0.9999999999)
    return Infinity;
  if (dof === 1) {
    return Math.tan(Math.PI * (p - 0.5));
  }
  if (dof === 2) {
    return 2 * (p - 0.5) * Math.sqrt(2 / (4 * p * (1 - p)));
  }
  let sign = -1;
  if (p >= 0.5) {
    sign = 1;
    p = 2 * (1 - p);
  } else {
    sign = -1;
    p = 2 * p;
  }
  const a = 1 / (dof - 0.5);
  const b = 48 / a ** 2;
  let c = ((20700 * a / b - 98) * a - 16) * a + 96.36;
  const d = ((94.5 / (b + c) - 3) / b + 1) * Math.sqrt(a * Math.PI / 2) * dof;
  let x = d * p;
  let y = x ** (2 / dof);
  if (y > 0.05 + a) {
    x = qnorm(p * 0.5);
    y = x ** 2;
    if (dof < 5) {
      c = c + 0.3 * (dof - 4.5) * (x + 0.6);
    }
    c = (((0.05 * d * x - 5) * x - 7) * x - 2) * x + b + c;
    y = (((((0.4 * y + 6.3) * y + 36) * y + 94.5) / c - y - 3) / b + 1) * x;
    y = a * y ** 2;
    y = y > 2e-3 ? Math.exp(y) - 1 : 0.5 * y ** 2 + y;
  } else {
    y = ((1 / (((dof + 6) / (dof * y) - 0.089 * d - 0.822) * (dof + 2) * 3) + 0.5 / (dof + 4)) * y - 1) * (dof + 1) / (dof + 2) + 1 / y;
  }
  return sign * Math.sqrt(dof * y);
}
function df(F, d1, d2) {
  if (F < 0 || d1 < 0 || d2 < 0) {
    throw new Error("All 3 parameters must be positive.");
  }
  if (d2 <= d1) {
    throw new Error("Parameter 'd1' must be larger 'd2'.");
  }
  if (Array.isArray(F)) {
    return F.map((v) => df(v, d1, d2));
  }
  return Math.sqrt((d1 * F) ** d1 * d2 ** d2 / (d1 * F + d2) ** (d1 + d2)) / (F * beta(d1 / 2, d2 / 2));
}
function pf(F, d1, d2) {
  if (F < 0 || d1 < 0 || d2 < 0) {
    throw new Error("All 3 parameters must be positive.");
  }
  if (Array.isArray(F)) {
    return F.map((v) => pf(v, d1, d2));
  }
  return ibeta(d1 * F / (d1 * F + d2), d1 / 2, d2 / 2);
}
function sort(x, decreasing = false) {
  return decreasing ? [...x].sort((a, b) => b - a) : [...x].sort((a, b) => a - b);
}
function rep(x, n) {
  if (Array.isArray(n)) {
    if (x.length != n.length) {
      throw new Error("Parameter 'n' should be a single value or a vector of the same length as x.");
    }
    let out = [];
    for (let i = 0; i < n.length; i++) {
      out.push(...rep([x[i]], n[i]));
    }
    return out;
  }
  if (!Array.isArray(x))
    x = [x];
  if (n <= 1)
    return x;
  const nx = x.length;
  x.length = nx * n;
  for (let i = 0; i < n - 1; i++) {
    for (let j = 0; j < nx; j++) {
      x[nx * (i + 1) + j] = x[j];
    }
  }
  return x;
}
function subset(x, indices, method) {
  if (!Array.isArray(x))
    x = [x];
  if (!Array.isArray(indices))
    indices = [indices];
  if (indices.length === 0)
    return [...x];
  if (max(indices) > x.length || min(indices) < 1) {
    throw new Error("Parameter 'indices' must have values between 1 and 'x.length'.");
  }
  const n = indices.length;
  if (!method || method === "select") {
    let out = Array(n);
    for (let i = 0; i < n; i++) {
      out[i] = x[indices[i] - 1];
    }
    return out;
  }
  if (method === "remove") {
    let out = [...x];
    return out.filter((v, i) => !indices.includes(i + 1));
  }
  throw Error("Wrong value for argument 'method'.");
}
function expandGrid(...args) {
  const nargs = args.length;
  const d = args.map((v) => v.length);
  let orep = prod(d);
  let grid = Array(nargs);
  let repFac = 1;
  for (let i = 0; i < nargs; i++) {
    const x = args[i];
    const nx = x.length;
    orep = orep / nx;
    grid[i] = subset(x, rep(rep(seq(1, nx, nx), rep(repFac, nx)), orep));
    repFac = repFac * nx;
  }
  return grid;
}
function shuffle(x) {
  let y = [...x];
  let n = y.length;
  let t, i;
  while (n) {
    i = Math.floor(Math.random() * n--);
    t = y[n];
    y[n] = y[i];
    y[i] = t;
  }
  return y;
}
function closestIndex(x, a) {
  const c = x.reduce((prev, curr) => Math.abs(curr - a) < Math.abs(prev - a) ? curr : prev);
  return x.indexOf(c);
}
function round(x, n = 0) {
  if (Array.isArray(x)) {
    return x.map((v) => round(v, n));
  }
  return Number.parseFloat(x.toFixed(n));
}
function scale(x, center = void 0, scale2 = void 0) {
  if (center === void 0)
    center = mean(x);
  if (scale2 === void 0)
    scale2 = sd(x);
  const n = x.length;
  let y = Array(n);
  for (let i = 0; i < n; i++) {
    y[i] = (x[i] - center) / scale2;
  }
  return y;
}
function integrate(f, a, b, acc = 1e-6, eps = 1e-5, oldfs = void 0) {
  if (typeof a !== "number" || typeof b !== "number") {
    throw Error("Parameters 'a' and 'b' must be numbers.");
  }
  if (b < a) {
    throw Error("Parameter 'b' must be larger 'a'.");
  }
  if (a === -Infinity && b !== Infinity) {
    return integrate((t) => f(b - (1 - t) / t) / t ** 2, 0, 1);
  }
  if (a !== -Infinity && b === Infinity) {
    return integrate((t) => f(a + (1 - t) / t) / t ** 2, 0, 1);
  }
  if (a === -Infinity && b === Infinity) {
    return integrate((t) => (f((1 - t) / t) + f((t - 1) / t)) / t ** 2, 0, 1);
  }
  const x = [1 / 6, 2 / 6, 4 / 6, 5 / 6];
  const w = [2 / 6, 1 / 6, 1 / 6, 2 / 6];
  const v = [1 / 4, 1 / 4, 1 / 4, 1 / 4];
  const p = [1, 0, 0, 1];
  let n = x.length, h = b - a;
  let fs;
  if (oldfs === void 0) {
    fs = x.map((v2) => f(a + v2 * h));
  } else {
    fs = new Array(n);
    for (let k = 0, i = 0; i < n; i++) {
      fs[i] = p[i] === 1 ? f(a + x[i] * h) : oldfs[k++];
    }
  }
  let q4 = 0, q2 = 0;
  for (let i = 0; i < n; i++) {
    q4 += w[i] * fs[i] * h;
    q2 += v[i] * fs[i] * h;
  }
  if (isNaN(q2) || isNaN(q4)) {
    throw Error("Numerical integration ended up with NaN number.");
  }
  let tol = acc + eps * Math.abs(q4);
  let err = Math.abs((q4 - q2) / 3);
  if (err < tol)
    return q4;
  acc = acc / Math.sqrt(2);
  let mid = (a + b) / 2;
  let left = fs.filter((v2, i) => i < n / 2);
  let right = fs.filter((v2, i) => i >= n / 2);
  let ql = integrate(f, a, mid, eps, acc, left);
  let qr = integrate(f, mid, b, eps, acc, right);
  return ql + qr;
}
function erf(x) {
  const sign = x >= 0 ? 1 : -1;
  x = Math.abs(x);
  const a1 = 0.254829592;
  const a2 = -0.284496736;
  const a3 = 1.421413741;
  const a4 = -1.453152027;
  const a5 = 1.061405429;
  const p = 0.3275911;
  const t = 1 / (1 + p * x);
  const y = 1 - ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
  return sign * y;
}
function gamma(z) {
  if (Array.isArray(z)) {
    return z.map((v) => gamma(v));
  }
  if (z <= 0) {
    throw new Error("Gamma function only works with arguments > 0.");
  }
  const p = [
    676.5203681218851,
    -1259.1392167224028,
    771.3234287776531,
    -176.6150291621406,
    12.507343278686905,
    -0.13857109526572012,
    9984369578019572e-21,
    15056327351493116e-23
  ];
  if (z < 0.5) {
    return Math.PI / (Math.sin(Math.PI * z) + gamma(1 - z));
  }
  z = z - 1;
  let x = 0.9999999999998099;
  for (let i = 0; i < p.length; i++) {
    x = x + p[i] / (z + i + 1);
  }
  const t = z + p.length - 0.5;
  return Math.sqrt(2 * Math.PI) * Math.pow(t, z + 0.5) * Math.exp(-t) * x;
}
function beta(x, y) {
  if (y > 100) {
    return integrate((u) => Math.pow(u, x - 1) / Math.pow(1 + u, x + y), 0, Infinity);
  }
  return gamma(x) * gamma(y) / gamma(x + y);
}
function ibeta(x, a, b) {
  if (x === 0)
    return 0;
  if (x === 1)
    return 1;
  if (b === 1)
    return x ** a;
  if (a === 1)
    return 1 - (1 - x) ** b;
  return integrate((t) => t ** (a - 1) * (1 - t) ** (b - 1), 0, x) / beta(a, b);
}

export {
  getPValue,
  tTest1,
  tTest2,
  kurtosis,
  skewness,
  min,
  max,
  sum,
  prod,
  mean,
  cov,
  variance,
  sd,
  cor,
  quantile,
  seq,
  range,
  mrange,
  split,
  count,
  mids,
  diff,
  getOutliers,
  rank,
  ppoints,
  cumsum,
  runif,
  dunif,
  punif,
  rnorm,
  dnorm,
  pnorm,
  qnorm,
  dt,
  pt,
  qt,
  df,
  pf,
  sort,
  rep,
  subset,
  expandGrid,
  shuffle,
  closestIndex,
  round,
  scale,
  integrate,
  erf,
  gamma,
  beta,
  ibeta
};
//# sourceMappingURL=chunk-H25KALKT.js.map
