{
  "version": 3,
  "sources": ["../../mdatools/stat/index.js"],
  "sourcesContent": ["/**********************************************\n * Functions for statistical tests and models *\n **********************************************/\n\n/**\n * Returns a p-value for any test\n * @param {function} pfun - reference to a CDF function (e.g. pnorm)\n * @param {number} crit - critical value for the test (e.g. z-score or t-score)\n * @param {string} tail - which tail to use (\"left\", \"right\", or \"both\")\n * @param {Array} params - additional parameters to CDF function\n * @returns {number} - a p-value for the test\n */\nexport function getPValue(pfun, crit, tail, params = []) {\n\n   if (tail === \"left\") {\n      return(pfun(crit, ...params));\n   }\n\n   if (tail === \"right\") {\n      return(1 - pfun(crit, ...params));\n   }\n\n   if (tail === \"both\") {\n      let p = pfun(crit, ...params);\n      return min([p, 1 - p]) * 2;\n   }\n}\n\n\n/**\n * Makes one-sample t-test for a mean\n * @param {number[]} x - vector with sample values\n * @param {number} mu - assumed mean value for population (H0)\n * @param {number} alpha - significance level (used to compute confidence interval)\n * @param {string} tail - which tail to use (\"left\", \"right\", or \"both\")\n * @returns {Object} - a JSON with test results\n */\nexport function tTest1(x, mu = 0, alpha = 0.05, tail = \"both\") {\n\n   if (typeof(mu) !== \"number\") {\n      throw Error(\"Parameter 'mu' should be a number.\");\n   }\n\n   const nx = x.length;\n\n   const effectExpected = mu;\n   const effectObserved = mean(x);\n   const se = sd(x) / Math.sqrt(nx);\n   const tValue = (effectObserved - effectExpected) / se;\n   const DoF = nx - 1\n   const errMargin = qt(1 - alpha/2, DoF) * se;\n\n   return {\n      test: \"One sample t-test\",\n      effectExpected: mu,\n      effectObserved: effectObserved,\n      se: se,\n      tValue: tValue,\n      alpha: alpha,\n      tail: tail,\n      DoF: DoF,\n      pValue: getPValue(pt, tValue, tail, [DoF]),\n      ci: [effectObserved - errMargin, effectObserved + errMargin]\n   };\n}\n\n/**\n * Makes two-sample t-test for a difference of means assuming population variances equal\n * @param {number[]} x - vector with sample 1 values\n * @param {number[]} y - vector with sample 2 values\n * @param {number} alpha - significance level (used to compute confidence interval)\n * @param {string} tail - which tail to use (\"left\", \"right\", or \"both\")\n * @returns {Object} - a JSON with test results\n */\nexport function tTest2(x, y, alpha = 0.05, tail = \"both\") {\n   const nx = x.length;\n   const mx = mean(x);\n   const my = mean(y);\n   const ny = y.length;\n\n   const effectExpected = 0;\n   const effectObserved = mx - my;\n   const se = Math.sqrt( (sd(x)**2 / nx) + (sd(y)**2 / ny));\n   const tValue = (effectObserved - effectExpected) / se;\n   const DoF = (nx - 1) + (ny - 1);\n   const errMargin = qt(1 - alpha/2, DoF) * se;\n\n   return {\n      test: \"Two sample t-test\",\n      effectExpected: effectExpected,\n      effectObserved: effectObserved,\n      se: se,\n      tValue: tValue,\n      alpha: alpha,\n      tail: tail,\n      DoF: DoF,\n      pValue: getPValue(pt, tValue, tail, [DoF]),\n      ci: [effectObserved - errMargin, effectObserved + errMargin]\n   };\n}\n\n/**********************************************\n * Functions for computing single statistics  *\n **********************************************/\n\n/**\n * Computes kurtosis of values\n * @param {number[]} x - vector with values\n * @returns {number}\n */\nexport function kurtosis(x) {\n   let n = x.length;\n   let m = mean(x);\n\n   let m4 = 0.0;\n   let m2 = 0.0;\n   for (let i = 0; i < n; i++) {\n      m2 = m2 + Math.pow((x[i] - m), 2);\n      m4 = m4 + Math.pow((x[i] - m), 4);\n   }\n\n   return (m4/n) / Math.pow((m2/n), 2);\n}\n\n\n/**\n * Computes skewness of values\n * @param {number[]} x - vector with values\n * @returns {number}\n */\nexport function skewness(x) {\n   let n = x.length;\n   let m = mean(x);\n\n   let m3 = 0.0;\n   let m2 = 0.0;\n   for (let i = 0; i < n; i++) {\n      m2 = m2 + Math.pow((x[i] - m), 2);\n      m3 = m3 + Math.pow((x[i] - m), 3);\n   }\n\n   return (m3/n) / Math.pow((m2/n), 1.5);\n}\n\n\n/**\n * Finds smallest value in a vector\n * @param {number[]} x - vector with values\n * @returns {number}\n */\nexport function min(x) {\n   let n = x.length;\n   let min = Number.POSITIVE_INFINITY\n\n   while (n--) min = x[n] < min ? x[n] : min;\n   return min;\n}\n\n\n/**\n * Finds largest value in a vector\n * @param {number[]} x - vector with values\n * @returns {number}\n */\nexport function max(x) {\n   let n = x.length;\n   let max = Number.NEGATIVE_INFINITY\n\n   while (n--) max = x[n] > max ? x[n] : max;\n   return max;\n}\n\n\n/**\n * Computes sum of all values in a vector\n * @param {number[]} x - vector with values\n * @returns {number}\n */\nexport function sum(x) {\n   let s = 0;\n   for (let i = 0; i < x.length; i++) {\n      s = s + x[i];\n   }\n\n   return s;\n}\n\n\n/**\n * Computes product of all value in a vector\n * @param {number[]} x - vector with values\n * @returns {number}\n */\nexport function prod(x) {\n   let p = 1;\n   for (let i = 0; i < x.length; i++) {\n      p = p * x[i];\n   }\n\n   return p;\n}\n\n\n/**\n * Computes mean (average) value for a vector\n * @param {number[]} x - vector with values\n * @returns {number}\n */\nexport function mean(x) {\n   return sum(x) / x.length;\n}\n\n\n/**\n * Computes covariance between two vectors\n * @param {number[]} x - vector with values\n * @param {number[]} y - vector with values\n * @param {boolean} biased - compute a biased version with n degrees of freedom or not (with n-1).\n * @param {number} mx - mean of x values (if already known)\n * @param {number} my - mean of y values (if already known)\n * @returns {number}\n */\nexport function cov(x, y, biased = false, mx = undefined, my = undefined) {\n\n   const n = x.length;\n\n   if (y.length !== n) {\n      throw Error(\"Vectors 'x' and 'y' must have the same length.\");\n   }\n\n   if (n < 2) {\n      throw Error(\"Vectors 'x' and 'y' must have at least two values.\");\n   }\n\n   if (mx === undefined) mx = mean(x);\n   if (my === undefined) my = mean(y);\n\n   let cov = 0;\n   for (let i = 0; i < n; i++) {\n      cov = cov + (x[i] - mx) * (y[i] - my);\n   }\n\n   return cov / (biased ? n : n - 1);\n}\n\n\n/**\n * Computes variance for a vector\n * @param {number[]} x - vector with values\n * @param {boolean} biased - compute a biased version with n degrees of freedom or not (with n-1).\n * @param {number} m - mean value (e.g. if already computed).\n * @returns {number}\n */\nexport function variance(x, biased = false, m = undefined) {\n   return cov(x, x, biased, m, m);\n}\n\n\n/**\n * Computes standard deviation for a vector\n * @param {number[]} x - vector with values\n * @param {boolean} biased - compute a biased version with n degrees of freedom or not (with n-1).\n * @param {number} m - mean value (e.g. if already computed).\n * @returns {number}\n */\nexport function sd(x, biased = false, m = undefined) {\n   return Math.sqrt(variance(x, biased, m));\n}\n\n\n/**\n * Computes correlation between two vectors\n * @param {number[]} x - vector with values\n * @param {number[]} y - vector with values\n * @param {string} method - which method to use (\"pearson\" or \"spearman\")\n * @returns {number}\n */\nexport function cor(x, y, method = \"pearson\") {\n\n   if (method === \"spearman\") {\n      return cor(rank(x), rank(y));\n   }\n\n   return cov(x, y) / (sd(x) * sd(y));\n}\n\n\n\n/***************************************************\n * Functions for computing vectors of statistics   *\n ***************************************************/\n\n\n/**\n * Computes a p-th quantile/quantiles for a numeric vector\n * @param {number[]} x - vector with values\n * @param {number|number[]} p - probability (one value or a vector)\n * @returns {number}\n */\nexport function quantile(x, p) {\n\n   x = sort(x);\n   const n = x.length;\n\n   if (!Array.isArray(p)) p = [p];\n   if (typeof(p[0]) !== \"number\" || min(p) < 0 || max(p) > 1) {\n      throw new Error(\"Parameter 'p' must be between 0 and 1 (both included).\");\n   }\n\n   function q(x, p) {\n      const h = (n - 1) * p + 1;\n      const n1 = Math.floor(h);\n      const n2 = Math.ceil(h);\n      return x[n1 - 1] + (x[n2 - 1] - x[n1 - 1]) * (h - Math.floor(h));\n   }\n\n   const out =  p.map(v => q(x, v));\n   return p.length == 1 ? out[0] : out;\n}\n\n\n/**\n * Generate a sequence of n numbers between min and max.\n * @param {number} min - first value in the sequence\n * @param {number} max - last value in the sequence\n * @param {number} n - number of values in the sequence\n * @returns {number[]} array with the sequence values\n */\nexport function seq(min, max, n) {\n\n   if (n < 2) {\n      throw new Error(\"Parameter 'n' should be \u2265 2.\");\n   }\n\n   if (n === undefined && Number.isInteger(min) && Number.isInteger(max)) {\n      if (max === min) return [max];\n      n = max - min + 1;\n   }\n\n   const step = (max - min + 0.0) / (n - 1 + 0.0)\n   let out = [...Array(n)].map((x, i) => min + i * step);\n\n   // if step is smaller than 1 round values to remove small decimals accidentally added by JS\n   if (Math.abs(step) < 1) {\n      const r = Math.pow(10, Math.round(-Math.log10(step)) + 1);\n      out = out.map(v => Math.round((v + Number.EPSILON) * r) / r)\n   }\n\n   return(out)\n}\n\n\n/**\n * Finds a range of values in a vector (min and max)\n * @param {number[]} x - vector with values\n * @returns {number[]} array with min and max values\n */\nexport function range(x) {\n   return [min(x), max(x)];\n}\n\n\n/**\n * Computes a range of values in a vector with a margin\n * @param {number[]} x - vector with values\n * @param {number} margin - margin in parts of one (e.g. 0.1 for 10% or 2 for 200%)\n * @returns{number[]} array with marginal range boundaries\n */\nexport function mrange(x, margin = 0.05) {\n   const mn = min(x);\n   const mx = max(x);\n   const d = mx - mn;\n\n   return [mn - d * margin, max(x) + d * margin];\n}\n\n\n/**\n * Splits range of vector values into equal intervals\n * @param {number[]} x - vector with values\n * @param {number} n - number of intervals\n * @returns {number[]} vector with boundaries of the intervals\n */\nexport function split(x, n) {\n   if (x === undefined || !Array.isArray(x) ||\u00A0x.length < 2) {\n      throw new Error(\"split: 'x' must bet a vector with numbers.\");\n   }\n\n   if (n === undefined || n < 2) {\n      throw new Erro(\"split: 'n' must be a positive integer number.\");\n   }\n\n   const mn = min(x);\n   const mx = max(x);\n\n   if (mn === mx) {\n      throw new Error(\"split: values in a vector 'x' should vary.\");\n   }\n\n   const step = (mx - mn) / n;\n   return Array.from({length: n + 1}, (v, i) => mn + i * step + 0.0);\n}\n\n\n/**\n * Counts how many values from a vector falls into provided intervals (bins)\n * @param {number[]} x - vector with values\n * @param {number[]} bins - vector with bins boundaries\n * @returns {number[]} vector with counts for each bean\n */\nexport function count(x, bins) {\n\n   if (x === undefined || !Array.isArray(x) ||x.length < 2) {\n      throw new Error(\"count: 'x' must be a vector with numbers.\")\n   }\n\n   if (bins === undefined || !Array.isArray(bins) ||\u00A0bins.length < 2) {\n      throw new Error(\"count: 'bins' must be a vector with numbers.\")\n   }\n\n   const n = bins.length;\n\n   // add a bit extra to right side of the last bin\n   bins[n - 1] = bins[n - 1] * 1.0001\n\n   // count\n   let counts = Array(n - 1).fill(0);\n   for (let i = 0; i < x.length; i++) {\n      for (let j = 0; j < n - 1; j++) {\n         if (x[i] >= bins[j] && x[i] < bins[j + 1]) counts[j] = counts[j] + 1;\n      }\n   }\n   return counts;\n}\n\n\n/**\n * Computes middle points between values of a vector\n * @param {number[]} x - vector with values\n * @returns {number[]} vector with middle points\n */\nexport function mids(x) {\n   return x.slice(1).map((v, i) => (0.5 * (v + x[i])));\n}\n\n\n/**\n * Computes difference between all adjacent values in a vector\n * @param {number[]} x - vector with values\n * @returns {number[]} vector with the differences\n */\nexport function diff(x) {\n   return x.slice(1).map( (y, i) => (y - x[i]));\n}\n\n\n/**\n * Finds outliers in a vector based on inter-quartile range distance\n * @param {Array} x - vector with values\n * @param {number} Q1 - first quartile (optional parameter)\n * @param {Array} Q3 - third quartile (optional parameter)\n * @returns {Array} vector with outliers or empty vector if none were found.\n */\nexport function getOutliers(x, Q1 = undefined, Q3 = undefined) {\n\n   if (Q1 === undefined) Q1 = quantile(x, 0.25);\n   if (Q3 === undefined) Q3 = quantile(x, 0.75);\n\n   const IQR = Q3 - Q1;\n   const bl = Q1 - 1.5 * IQR\n   const bu = Q3 + 1.5 * IQR\n   return(x.filter(v => v < bl || v > bu));\n}\n\n\n/**\n * Returns ranks of values in a vector (ranks start from 1, not 0)\n * @param {number[]} x - vector with values\n * @returns {number[]} vector with ranks\n */\nexport function rank(x) {\n   const y = [...x].sort((a, b) => a - b);\n   return(x.map(v => y.indexOf(v) + 1));\n}\n\n\n/**\n * Generate probability points for QQ plot\n * @param {number} n - number of points\n * @returns {Array} a sequence of probabilities between 0 and 1\n */\nexport function ppoints(n) {\n   const a = n < 10 ? 3.0/8.0 : 0.5;\n   return Array.from({length: n}, (v, i) => (i + 1 - a) / (n + (1 - a) - a));\n}\n\n\n/**\n * Computes cumulative sums for the vector values\n * @param {number[]} x - vector with values\n * @returns {number[]}\n */\nexport function cumsum(x) {\n   let s = 0;\n   return x.map(v => s += v);\n}\n\n\n\n/***********************************************\n * Functions for theoretical distribution      *\n ***********************************************/\n\n\n/**\n * Generates 'n' random numbers from a uniform distribution\n * @param {number} n - amount of numbers to generate\n * @param {number} a - smallest value (min) of the population\n * @param {number} b - largest value (max) of the population\n * @returns {number[]} vector with generated numbers\n */\nexport function runif(n, a = 0, b = 1) {\n   let out = Array(n);\n   for (let i = 0; i < n; i++) out[i] = (a + Math.random() * (b - a));\n   return out;\n}\n\n\n/**\n * Probability density function for uniform distribution\n * @param {Array} x - vector of values\n * @param {number} a - smallest value (min) of the population\n * @param {number} b - largest value (max) of the population\n * @returns {Array} vector with densities\n */\nexport function dunif(x, a = 0, b = 1) {\n\n   if (!Array.isArray(x)) x = [x];\n\n   const n = x.length;\n   const A = 1 / (b - a);\n   let d = Array(n);\n\n   for (let i = 0; i < n; i++) {\n      d[i] = (x[i] < a || x[i] > b ) ? 0 : A;\n   }\n\n   return d;\n}\n\n\n/**\n * Cumulative distribution function for uniform distribution\n * @param {Array} x - vector of values\n * @param {number} a - smallest value (min) of the population\n * @param {number} b - largest value (max) of the population\n * @returns {Array} vector with probabilities\n */\nexport function punif(x, a = 0, b = 1) {\n\n   if (!Array.isArray(x)) x = [x];\n\n   const n = x.length;\n   let p = Array(n);\n   for (let i = 0; i < n; i++) {\n      if (x[i] < a) {\n         p[i] = 0;\n      } else if (x[i] > b) {\n         p[i] = 1;\n      } else {\n         p[i] = (x[i] - a) / (b - a)\n      }\n   }\n\n   return p;\n}\n\n\n /**\n * Generates 'n' random numbers from a normal distribution\n * @param {number} n - amount of numbers to generate\n * @param {number} mu - average value of the population\n * @param {number} sigma - standard deviation of the population\n * @returns {Array} vector with generated numbers\n */\nexport function rnorm(n, mu = 0, sigma = 1) {\n\n   let out = Array(n);\n   for (let i = 0; i < n; i ++) {\n      const a = Math.sqrt(-2 * Math.log(Math.random()));\n      const b = 2 * Math.PI * Math.random();\n      out[i] = (a * Math.sin(b) * sigma + mu);\n   }\n\n   return out;\n}\n\n\n/**\n * Probability density function for normal distribution\n * @param {Array} x - vector of values\n * @param {number} mu - average value of the population\n * @param {number} sigma - standard deviation of the population\n * @returns {Array} vector with densities\n */\nexport function dnorm(x, mu = 0, sigma = 1) {\n\n   if (!Array.isArray(x)) x = [x];\n\n   const n = x.length;\n   const A = 1 / (Math.sqrt(2 * Math.PI) * sigma);\n   const frac = -0.5 / sigma ** 2;\n\n   let d = Array(n);\n   for (let i = 0; i < n; i++) {\n      const df = x[i] - mu;\n      d[i] = A * Math.exp(frac * df * df);\n   }\n\n   return x.length === 1 ? d[0] : d;\n}\n\n\n/**\n * Cumulative distribution function for normal distribution\n * @param {Array} x - vector of values\n * @param {number} mu - average value of the population\n * @param {number} sigma - standard deviation of the population\n * @returns {Array} vector with probabilities\n */\nexport function pnorm(x, mu = 0, sigma = 1) {\n\n   if (!Array.isArray(x)) x = [x];\n\n   const n = x.length;\n   const frac = 1 / (Math.sqrt(2) * sigma);\n\n   let p = Array(n);\n   for (let i = 0; i < n; i++) {\n      p[i] = 0.5 * (1 + erf((x[i] - mu) * frac))\n   }\n\n   return p.length === 1 ? p[0] : p;\n}\n\n/**\n * Inverse cumulative distribution function for normal distribution\n * @param {number|number[]} p - vector of probabilities or a single probability value\n * @param {number} mu - average value of the population\n * @param {number} sigma - standard deviation of the population\n * @returns {number|number[]} vector with quantiles or single quantile value\n */\nexport function qnorm(p, mu = 0, sigma = 1) {\n\n   if (Array.isArray(p)) {\n      return p.map(v => qnorm(v, mu, sigma));\n   }\n\n   if (mu !== 0 ||\u00A0sigma !== 1) {\n      return qnorm(p) * sigma + mu;\n   }\n\n   if (p < 0 ||\u00A0p > 1) {\n      throw Error(\"Parameter 'p' must be between 0 and 1.\");\n   }\n\n   if (p < 0.0000000001) return -Infinity;\n   if (p > 0.9999999999) return +Infinity;\n\n   const SP1 = 0.425;\n   const SP2 = 5.0;\n   const C1 = 0.180625;\n   const C2 = 1.6;\n\n   const a0 = 3.3871327179;\n   const a1 = 5.0434271938 * 10;\n   const a2 = 1.5929113202 * 100;\n   const a3 = 5.9109374720 * 10;\n   const b1 = 1.7895169469 * 10;\n   const b2 = 7.8757757664 * 10;\n   const b3 = 6.7187563600 * 10;\n\n   const c0 = 1.4234372777;\n   const c1 = 2.7568153900;\n   const c2 = 1.3067284816;\n   const c3 = 1.7023821103 * 0.1;\n   const d1 = 7.3700164250 * 0.1;\n   const d2 = 1.2021132975 * 0.1;\n\n   const e0 = 6.6579051150;\n   const e1 = 3.0812263860;\n   const e2 = 4.2868294337 * 0.1;\n   const e3 = 1.7337203997 * 0.01;\n   const f1 = 2.4197894225 * 0.1;\n   const f2 = 1.2258202635 * 0.01;\n\n   const q = p - 0.5;\n   let r;\n\n   if (Math.abs(q) <= SP1) {\n      r = C1 - q * q;\n      return q * (((a3 * r + a2) * r + a1) *r + a0) / (((b3 * r + b2) * r + b1) * r + 1.0);\n   }\n\n   r = q < 0 ? p : 1 - p;\n   r = Math.sqrt(-Math.log(r));\n   let res;\n\n   if (r <= SP2) {\n      r = r - C2;\n      res = (((c3 * r + c2) * r + c1) * r + c0) / ((d2 * r + d1) * r + 1.0);\n   } else {\n      r = r - SP2;\n      res = (((e3 * r + e2) * r + e1) + e0) / ((f2 * r + f1) * r + 1.0);\n   }\n\n   return q < 0 ? -res : res;\n}\n\n/**\n * Probability density function for Student's t-distribution\n * @param {number|number[]} t - t-value or a vector of t-values\n * @param {number} dof - degrees of freedom\n */\nexport function dt(t, dof) {\n\n   if (dof < 0) {\n      throw new Error(\"Parameter 'dof' should be a positive number.\");\n   }\n\n   if (Array.isArray(t))\u00A0{\n      return t.map(v => dt(v, dof));\n   }\n\n   const pow = -0.5 * (dof + 1);\n   const A = 1 / (Math.sqrt(dof) * beta(0.5, dof/2));\n   return (A * Math.pow((1 + t * t / dof), pow));\n}\n\n\n/**\n * Cumulative distribution function for Student's t-distribution\n * @param {number|number[]} t - t-value or a vector of t-values\n * @param {number} dof - degrees of freedom\n */\nexport function pt(t, dof) {\n\n   if (dof === undefined ||\u00A0dof === null || dof < 1) {\n      throw Error(\"Parameter 'dof' (degrees of freedom) must be an integer number >= 1.\");\n   }\n\n   if (Array.isArray(t))\u00A0{\n      return t.map(v => pt(v, dof));\n   }\n\n   // since distribution in symmetric we can use only left tail\n   if (t === 0) return 0.5;\n   if (t === -Infinity) return 0;\n   if (t === Infinity) return 1;\n   if (t > 0) return (1 - pt(-t, dof));\n\n   return integrate((x) => dt(x, dof), -Infinity, t);\n}\n\n\n/**\n * Inverse cumulative distribution function for Student's t-distribution\n * @param {number|number[]} p - probability or vector with probabilities\n * @param {number} dof - degrees of freedom\n */\nexport function qt(p, dof) {\n\n   if (dof === undefined ||\u00A0dof === null || dof < 1) {\n      throw Error(\"Parameter 'dof' (degrees of freedom) must be an integer number >= 1.\");\n   }\n\n   if (p < 0 ||\u00A0p > 1) {\n      throw Error(\"Parameter 'p' must be between 0 and 1.\");\n   }\n\n   if (Array.isArray(p))\u00A0{\n      return p.map(v => qt(v, dof));\n   }\n\n   if (p < 0.0000000001) return -Infinity;\n   if (p > 0.9999999999) return +Infinity;\n\n\n   // simple cases \u2014 exact solutions\n   if (dof === 1) {\n      return Math.tan(Math.PI * (p - 0.5));\n   }\n\n   if (dof === 2) {\n      return 2 * (p - 0.5) * Math.sqrt(2 / (4 * p * (1 - p)));\n   }\n\n   // approximation\n\n   let sign = -1;\n   if (p >= 0.5){\n      sign = +1 ;\n      p = 2 * (1 - p);\n   } else {\n      sign = -1;\n      p = 2 * p;\n   }\n\n   const a = 1.0 / (dof - 0.5);\n   const b = 48.0 / (a ** 2);\n   let c = ((20700 * a / b - 98) * a - 16) * a + 96.36;\n   const d = ((94.5 / (b + c) - 3.0)/b + 1.0) * Math.sqrt(a * Math.PI / 2) * dof;\n\n   let x = d * p;\n   let y = x ** (2.0/dof);\n\n   if (y > 0.05 + a) {\n\n      // asymptotic inverse expansion about normal\n      x = qnorm(p * 0.5);\n      y = x ** 2;\n\n      if (dof < 5) {\n         c = c + 0.3 * (dof - 4.5) * (x + 0.6);\n      }\n\n      c = (((0.05 * d * x - 5.0) * x - 7.0) * x - 2.0) * x + b + c;\n      y = (((((0.4 * y + 6.3) * y + 36.0) * y + 94.5) / c - y - 3.0)/b + 1.0) * x;\n      y = a * (y ** 2);\n      y = y > 0.002 ? Math.exp(y) - 1.0 : 0.5 * (y ** 2) + y;\n   } else {\n      y = ((1.0 / (((dof + 6.0)/(dof * y) - 0.089 * d - 0.822) * (dof + 2.0) * 3.0) + 0.5/(dof + 4.0)) * y - 1.0) *\n         (dof + 1.0)/(dof + 2.0) + 1.0/y;\n   }\n\n   return sign * Math.sqrt(dof * y);\n}\n\n\n\n/**\n * Probability density function for F-distribution\n * @param {number|number[]} F - F-value or a vector of t-values\n * @param {number} d1 - degrees of freedom\n * @param {number} d2 - degrees of freedom\n */\nexport function df(F, d1, d2) {\n\n   if (F < 0 ||\u00A0d1 < 0 || d2 < 0) {\n      throw new Error(\"All 3 parameters must be positive.\");\n   }\n\n   if (d2 <= d1) {\n      throw new Error(\"Parameter 'd1' must be larger 'd2'.\");\n   }\n\n   if (Array.isArray(F))\u00A0{\n      return F.map(v => df(v, d1, d2));\n   }\n\n   return Math.sqrt( ( (d1 * F)**d1 * d2**d2) / ((d1 * F + d2)**(d1 + d2))) / (F * beta(d1/2, d2/2))\n}\n\n\n/**\n * Cumulative distribution function for F-distribution\n * @param {number|number[]} F - F-value or a vector of t-values\n * @param {number} d1 - degrees of freedom\n * @param {number} d2 - degrees of freedom\n */\nexport function pf(F, d1, d2) {\n\n   if (F < 0 ||\u00A0d1 < 0 || d2 < 0) {\n      throw new Error(\"All 3 parameters must be positive.\");\n   }\n\n   if (Array.isArray(F))\u00A0{\n      return F.map(v => pf(v, d1, d2));\n   }\n\n   return ibeta(d1 * F / (d1 * F + d2), d1/2, d2/2)\n}\n\n\n\n/***********************************************\n * Functions for manipulations with values     *\n ***********************************************/\n\n\n/**\n * Sorts values in a vector\n * @param {Array} x - vector with values\n * @returns {Array} vector with sorted values\n */\nexport function sort(x, decreasing = false) {\n   return decreasing ? [...x].sort((a, b) => b - a) : [...x].sort((a, b) => a - b);\n}\n\n\n/**\n * Replicates values in x n times\n * @param {any} x - single value or a vector with values\n * @param {number} n - how many times to replicate\n */\nexport function rep(x, n) {\n\n   if (Array.isArray(n)) {\n      if (x.length != n.length) {\n         throw new Error(\"Parameter 'n' should be a single value or a vector of the same length as x.\");\n      }\n\n      let out = [];\n      for (let i = 0; i < n.length; i++) {\n         out.push(...rep([x[i]], n[i]));\n      }\n\n      return out;\n   }\n\n   if (!Array.isArray(x)) x = [x];\n   if (n <= 1) return x;\n\n   const nx = x.length;\n   x.length = nx * n\n   for (let i = 0; i < n - 1; i ++) {\n      for (let j = 0; j < nx; j++) {\n         x[nx * (i + 1) + j] = x[j];\n      }\n   }\n\n   return x;\n}\n\n\n/**\n * Create a subset of vectors based on a vector of indices\n * @param {number[]} x - a vector with values\n * @param {number[]} indices - a vector with element indices (first index is 1 not 0!)\n * @param {string} method - what to do with values (\"select\" or \"remove\")\n */\nexport function subset(x, indices, method) {\n\n   if (!Array.isArray(x)) x = [x];\n   if (!Array.isArray(indices)) indices = [indices];\n\n   if (indices.length === 0) return [...x];\n\n   if (max(indices) > x.length ||\u00A0min(indices) < 1) {\n      throw new Error(\"Parameter 'indices' must have values between 1 and 'x.length'.\");\n   }\n\n   const n = indices.length;\n\n   if (!method || method === \"select\") {\n      let out = Array(n);\n      for (let i = 0; i < n; i++) {\n         out[i] = x[indices[i] - 1];\n      }\n      return out;\n   }\n\n   if (method === \"remove\") {\n      let out = [...x];\n      return out.filter((v, i) => !indices.includes(i + 1));\n   }\n\n   throw Error(\"Wrong value for argument 'method'.\");\n}\n\n\n/**\n * Generate combination of all levels of vectors\n * @param {...} args - a sequence of vectors\n */\nexport function expandGrid(...args) {\n\n   const nargs = args.length;\n   const d = args.map(v => v.length);\n   let orep = prod(d);\n\n   let grid = Array(nargs);\n   let repFac = 1;\n\n   for (let i = 0; i < nargs; i++) {\n      const x = args[i];\n      const nx = x.length;\n      orep = orep/nx;\n      grid[i] = subset(x, rep(rep(seq(1, nx, nx), rep(repFac, nx)), orep));\n      repFac = repFac * nx;\n   }\n\n   return grid;\n}\n\n\n/**\n * Shuffles values in vector x using Fisher\u2013Yates algorithm\n * @param {Array} x - a vector with values\n */\nexport function shuffle(x) {\n  let y = [...x];\n  let n = y.length;\n  let t, i;\n\n  while (n) {\n    i = Math.floor(Math.random() * n--);\n    t = y[n];\n    y[n] = y[i];\n    y[i] = t;\n  }\n\n  return y;\n}\n\n\n/**\n * Finds index of value in x which is closest to the value a\n * @param {number[]} x - a vector with values\n * @param {number}  a - a value\n */\nexport function closestIndex(x, a) {\n   const c = x.reduce((prev, curr) => Math.abs(curr - a) < Math.abs(prev - a) ? curr : prev);\n   return x.indexOf(c);\n}\n\n\n/**\n * Rounds number (or vector of numbers) to given amount of decimals\n * @param {number | number[]} x - a vector with values\n * @return {number | number[]}\n */\nexport function round(x, n = 0) {\n   if (Array.isArray(x)) {\n      return x.map(v => round(v, n));\n   }\n   return Number.parseFloat(x.toFixed(n));\n}\n\n/**\n * Standardize (mean center and sd scale) values from a vector\n * @param {number | number[]} x - a vector with values\n * @return {number} center - value for centering the values (if undefined, will use mean(x))\n * @return {number} scale - value for scaling the values (if undefined, will use sd(x))\n *\n */\nexport function scale(x, center = undefined, scale = undefined) {\n   if (center === undefined) center = mean(x);\n   if (scale === undefined) scale = sd(x);\n\n   const n = x.length;\n   let y = Array(n);\n\n   for (let i = 0; i < n; i++) {\n      y[i] = (x[i] - center) / scale;\n   }\n\n   return y;\n}\n\n\n\n/***************************************************************\n * Mathematical functions and methods needed for computations  *\n ***************************************************************/\n\n/**\n * Computes numeric integral for function \"f\" with limits (a, b)\n * @param {function} f - a reference to a function\n * @param {number} a - lower limit for integration\n * @param {number} b - upper limit for integration\n * @param {number} acc - absolute accuracy\n * @param {number} eps - relative accuracy\n * @param {number[]} oldfs - vector of values needed for recursion\n * @returns {number} result of integration\n */\nexport function integrate(f, a, b, acc = 0.000001, eps = 0.00001, oldfs = undefined) {\n\n   if (typeof(a) !== \"number\" ||\u00A0typeof(b) !== \"number\") {\n      throw Error(\"Parameters 'a' and 'b' must be numbers.\");\n   }\n\n   if (b < a) {\n      throw Error(\"Parameter 'b' must be larger 'a'.\");\n   }\n\n   // special case when left limit is minus infinity\n   if (a === -Infinity && b !== Infinity) {\n      return integrate((t) => f(b - (1 - t) / t) / (t ** 2), 0, 1);\n   }\n\n   // special case when right limit is plus infinity\n   if (a !== -Infinity && b === Infinity) {\n      return integrate((t) => f(a + (1 - t) / t) / (t ** 2), 0, 1);\n   }\n\n   // special case when both limits are infinite\n   if (a === -Infinity && b === Infinity) {\n      return integrate((t) => (f((1 - t) / t) + f((t - 1) / t)) / t ** 2, 0, 1);\n   }\n\n   // constants for splitting the integration interval\n   const x = [1/6, 2/6, 4/6, 5/6];\n   const w = [2/6, 1/6, 1/6, 2/6];\n   const v = [1/4, 1/4, 1/4, 1/4];\n   const p = [1, 0, 0, 1];\n\n   let n = x.length, h = b - a;\n   let fs;\n\n   if (oldfs === undefined) {\n      fs = x.map(v => f(a + v * h));\n   } else {\n      fs = new Array(n);\n      for (let k = 0, i = 0; i < n; i++) {\n         fs[i] = p[i] === 1 ? f(a + x[i] * h) : oldfs[k++];\n      }\n   }\n\n   let q4 = 0, q2 = 0;\n   for (let i = 0; i < n; i++) {\n      q4 += w[i] * fs[i] * h;\n      q2 += v[i] * fs[i] * h;\n   }\n\n   if (isNaN(q2) || isNaN(q4)) {\n      throw Error(\"Numerical integration ended up with NaN number.\")\n   }\n\n   let tol = acc + eps * Math.abs(q4);\n   let err = Math.abs((q4 - q2)/3);\n\n   if (err < tol) return q4;\n\n   acc = acc / Math.sqrt(2.);\n   let mid = (a + b) / 2;\n   let left = fs.filter((v, i) => i < n/2);\n   let right = fs.filter((v, i) => i >= n/2);\n\n   let ql = integrate(f, a, mid, eps, acc, left);\n   let qr = integrate(f, mid, b, eps, acc, right);\n   return (ql + qr);\n}\n\n\n/**\n * Error function for normal distribution\n * @param {number} x - a number\n * @returns {number} value for erf\n */\nexport function erf(x) {\n\n  const sign = (x >= 0) ? 1 : -1;\n  x = Math.abs(x);\n\n  // constants\n  const a1 =  0.254829592;\n  const a2 = -0.284496736;\n  const a3 =  1.421413741;\n  const a4 = -1.453152027;\n  const a5 =  1.061405429;\n  const p  =  0.3275911;\n\n  // approximation\n  const t = 1.0 / (1.0 + p * x);\n  const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);\n  return sign * y;\n}\n\n\n/**\n * Gamma function (approximation)\n * @param {number|number[]} z - argument (one value or a vector)\n * @returns {number} value of the Gamma function\n */\nexport function gamma(z) {\n\n   if (Array.isArray(z))\u00A0{\n      return z.map(v => gamma(v));\n   }\n\n   if (z <= 0) {\n      throw new Error(\"Gamma function only works with arguments > 0.\");\n   }\n\n   // coefficients\n   const p = [\n        676.5203681218851,\n      -1259.1392167224028,\n        771.32342877765313,\n       -176.61502916214059,\n         12.507343278686905,\n         -0.13857109526572012,\n          9.9843695780195716e-6,\n          1.5056327351493116e-7\n    ];\n\n   if (z < 0.5) {\n      return Math.PI / (Math.sin(Math.PI * z) + gamma(1 - z));\n   }\n\n   z = z - 1;\n   let x = 0.99999999999980993;\n\n   for (let i = 0; i < p.length; i++) {\n      x = x + p[i] / (z + i + 1);\n   }\n\n   const t = z + p.length - 0.5;\n   return Math.sqrt(2 * Math.PI) * Math.pow(t, z + 0.5) * Math.exp(-t) * x;\n}\n\n\n/**\n * Betta function (approximation)\n * @param {number} x - first argument (one value)\n * @param {number} y - second argument (one value)\n * @returns {number} value of the Beta function\n */\nexport function beta(x, y) {\n\n   if (y > 100) {\n      // for large y we use slower integrate version\n      return integrate((u) => Math.pow(u, x - 1) / Math.pow(1 + u, x + y), 0, Infinity)\n   }\n\n   return gamma(x) * gamma(y) / gamma(x + y);\n}\n\n\n/**\n * Incomplete Betta function (approximation via numeric integration)\n * @param {number} x - first argument (one value)\n * @param {number} a - second argument (one value)\n * @param {number} b - third argument (one value)\n * @returns {number} value of the function\n */\nexport function ibeta(x, a, b) {\n   if (x === 0) return 0;\n   if (x === 1) return 1;\n   if (b === 1) return x ** a;\n   if (a === 1) return (1 - (1 - x)**b);\n   return integrate((t) => t ** (a - 1) * (1 - t) ** (b - 1), 0, x) / beta(a, b);\n}\n"],
  "mappings": "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",
  "names": ["min", "max", "cov", "x", "p", "df", "scale", "v"]
}
