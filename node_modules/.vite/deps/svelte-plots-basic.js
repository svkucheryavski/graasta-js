import {
  writable
} from "./chunk-QKQJIKFJ.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  add_location,
  append_dev,
  append_styles,
  attr_dev,
  binding_callbacks,
  check_outros,
  component_subscribe,
  createEventDispatcher,
  create_component,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  group_outros,
  init,
  insert_dev,
  listen_dev,
  mount_component,
  noop,
  onDestroy,
  onMount,
  run_all,
  safe_not_equal,
  setContext,
  set_data_dev,
  set_style,
  space,
  svg_element,
  text,
  toggle_class,
  transition_in,
  transition_out,
  update_slot_base,
  validate_each_argument,
  validate_slots,
  validate_store
} from "./chunk-BJ76AV5Z.js";
import {
  diff,
  max,
  mrange,
  rep,
  subset
} from "./chunk-H25KALKT.js";

// node_modules/svelte-plots-basic/src/Axes.svelte
var file = "node_modules/svelte-plots-basic/src/Axes.svelte";
function add_css(target) {
  append_styles(target, "svelte-1z0dyat", '.plot.svelte-1z0dyat{font-family:Arial, Helvetica, sans-serif;display:grid;grid-template-columns:min-content auto;grid-template-rows:min-content auto min-content;grid-template-areas:". title"\n         "ylab axes"\n         ". xlab";box-sizing:border-box;background:#fefefe;min-width:100px;min-height:50px;width:100%;height:100%;padding:0;margin:0}.plot_small{font-size:11px}.plot_medium{font-size:13px}.plot_large{font-size:16px}.plot_error{display:flex}.plot_error > .axes-wrapper{display:none}.message_error{font-size:1.2em;color:crimson;padding:1em;box-sizing:border-box;text-align:center}.axes-wrapper.svelte-1z0dyat{grid-area:axes;position:relative;box-sizing:border-box;display:flex;width:100%;height:100%;padding:0;margin:0}.axes{display:block;box-sizing:border-box;position:absolute;padding:0;margin:0;height:100%;width:100%;max-height:100%;max-width:100%;min-height:100%;min-width:100%}.axes-content{padding:0;margin:0;height:100%;width:100%;max-height:100%;max-width:100%;min-height:100%;min-width:100%}.axes__xlabel{grid-area:xlab;font-size:1.0em;font-weight:600;padding:0.25em;text-align:center}.axes__ylabel{grid-area:ylab;font-size:1.0em;font-weight:600;padding:0.25em;text-align:center;vertical-align:middle;display:flex}.axes__ylabel > span{width:1.5em;line-height:1.5em;display:inline-block;writing-mode:vertical-rl;transform:rotate(180deg)}.axes__title{background:transparent;grid-area:title;font-size:1.3em;font-weight:bold;line-height:1.2em;padding:0.5em 0;text-align:center}.axis-labels{fill:#303030;font-size:0.95em}.labels{fill:#606060;font-size:0.90em}.labels{visibility:hidden;transition:visibility 0.25s linear, opacity 0.25s linear;opacity:0}.svelte-1z0dyat{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQXhlcy5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBb1pHLEtBQUssZUFBQyxDQUFDLEFBQ0osV0FBVyxDQUFFLEtBQUssQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLFVBQVUsQ0FFekMsT0FBTyxDQUFFLElBQUksQ0FDYixxQkFBcUIsQ0FBRSxXQUFXLENBQUMsSUFBSSxDQUN2QyxrQkFBa0IsQ0FBRSxXQUFXLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FDaEQsbUJBQW1CLENBQ2hCLFNBQVM7U0FDVCxXQUFXO1NBQ1gsUUFBUSxDQUVYLFVBQVUsQ0FBRSxVQUFVLENBQ3RCLFVBQVUsQ0FBRSxPQUFPLENBQ25CLFNBQVMsQ0FBRSxLQUFLLENBQ2hCLFVBQVUsQ0FBRSxJQUFJLENBQ2hCLEtBQUssQ0FBRSxJQUFJLENBQ1gsTUFBTSxDQUFFLElBQUksQ0FDWixPQUFPLENBQUUsQ0FBQyxDQUNWLE1BQU0sQ0FBRSxDQUFDLEFBQ1osQ0FBQyxBQUVPLFdBQVcsQUFBRSxDQUFDLEFBQ25CLFNBQVMsQ0FBRSxJQUFJLEFBQ2xCLENBQUMsQUFFTyxZQUFZLEFBQUUsQ0FBQyxBQUNwQixTQUFTLENBQUUsSUFBSSxBQUNsQixDQUFDLEFBRU8sV0FBVyxBQUFFLENBQUMsQUFDbkIsU0FBUyxDQUFFLElBQUksQUFDbEIsQ0FBQyxBQUVPLFdBQVcsQUFBRSxDQUFDLEFBQ25CLE9BQU8sQ0FBRSxJQUFJLEFBQ2hCLENBQUMsQUFFTywyQkFBMkIsQUFBRSxDQUFDLEFBQ25DLE9BQU8sQ0FBRSxJQUFJLEFBQ2hCLENBQUMsQUFFTyxjQUFjLEFBQUUsQ0FBQyxBQUN0QixTQUFTLENBQUUsS0FBSyxDQUNoQixLQUFLLENBQUUsT0FBTyxDQUNkLE9BQU8sQ0FBRSxHQUFHLENBQ1osVUFBVSxDQUFFLFVBQVUsQ0FDdEIsVUFBVSxDQUFFLE1BQU0sQUFDckIsQ0FBQyxBQUdELGFBQWEsZUFBQyxDQUFDLEFBQ1osU0FBUyxDQUFFLElBQUksQ0FDZixTQUFTLFFBQVEsQ0FDakIsVUFBVSxDQUFFLFVBQVUsQ0FDdEIsT0FBTyxDQUFFLElBQUksQ0FDYixLQUFLLENBQUUsSUFBSSxDQUNYLE1BQU0sQ0FBRSxJQUFJLENBQ1osT0FBTyxDQUFFLENBQUMsQ0FDVixNQUFNLENBQUUsQ0FBQyxBQUNaLENBQUMsQUFFTyxLQUFLLEFBQUUsQ0FBQyxBQUNiLE9BQU8sQ0FBRSxLQUFLLENBQ2QsVUFBVSxDQUFFLFVBQVUsQ0FDdEIsU0FBUyxRQUFRLENBRWpCLE9BQU8sQ0FBRSxDQUFDLENBQ1YsTUFBTSxDQUFFLENBQUMsQ0FDVCxNQUFNLENBQUUsSUFBSSxDQUNaLEtBQUssQ0FBRSxJQUFJLENBQ1gsVUFBVSxDQUFFLElBQUksQ0FDaEIsU0FBUyxDQUFFLElBQUksQ0FDZixVQUFVLENBQUUsSUFBSSxDQUNoQixTQUFTLENBQUUsSUFBSSxBQUNsQixDQUFDLEFBRU8sYUFBYSxBQUFFLENBQUMsQUFDckIsT0FBTyxDQUFFLENBQUMsQ0FDVixNQUFNLENBQUUsQ0FBQyxDQUNULE1BQU0sQ0FBRSxJQUFJLENBQ1osS0FBSyxDQUFFLElBQUksQ0FDWCxVQUFVLENBQUUsSUFBSSxDQUNoQixTQUFTLENBQUUsSUFBSSxDQUNmLFVBQVUsQ0FBRSxJQUFJLENBQ2hCLFNBQVMsQ0FBRSxJQUFJLEFBRWxCLENBQUMsQUFFTyxhQUFhLEFBQUUsQ0FBQyxBQUNyQixTQUFTLENBQUUsSUFBSSxDQUNmLFNBQVMsQ0FBRSxLQUFLLENBQ2hCLFdBQVcsQ0FBRSxHQUFHLENBQ2hCLE9BQU8sQ0FBRSxNQUFNLENBQ2YsVUFBVSxDQUFFLE1BQU0sQUFDckIsQ0FBQyxBQUdPLGFBQWEsQUFBRSxDQUFDLEFBQ3JCLFNBQVMsQ0FBRSxJQUFJLENBQ2YsU0FBUyxDQUFFLEtBQUssQ0FDaEIsV0FBVyxDQUFFLEdBQUcsQ0FDaEIsT0FBTyxDQUFFLE1BQU0sQ0FDZixVQUFVLENBQUUsTUFBTSxDQUNsQixjQUFjLENBQUUsTUFBTSxDQUN0QixPQUFPLENBQUUsSUFBSSxBQUNoQixDQUFDLEFBRU8sb0JBQW9CLEFBQUUsQ0FBQyxBQUM1QixLQUFLLENBQUUsS0FBSyxDQUNaLFdBQVcsQ0FBRSxLQUFLLENBQ2xCLE9BQU8sQ0FBRSxZQUFZLENBQ3JCLFlBQVksQ0FBRSxXQUFXLENBQ3pCLFNBQVMsQ0FBRSxPQUFPLE1BQU0sQ0FBQyxBQUM1QixDQUFDLEFBR08sWUFBWSxBQUFFLENBQUMsQUFDcEIsVUFBVSxDQUFFLFdBQVcsQ0FDdkIsU0FBUyxDQUFFLEtBQUssQ0FFaEIsU0FBUyxDQUFFLEtBQUssQ0FDaEIsV0FBVyxDQUFFLElBQUksQ0FDakIsV0FBVyxDQUFFLEtBQUssQ0FDbEIsT0FBTyxDQUFFLEtBQUssQ0FBQyxDQUFDLENBQ2hCLFVBQVUsQ0FBRSxNQUFNLEFBQ3JCLENBQUMsQUFHTyxZQUFZLEFBQUUsQ0FBQyxBQUNwQixJQUFJLENBQUUsT0FBTyxDQUNiLFNBQVMsQ0FBRSxNQUFNLEFBQ3BCLENBQUMsQUFHTyxPQUFPLEFBQUUsQ0FBQyxBQUNmLElBQUksQ0FBRSxPQUFPLENBQ2IsU0FBUyxDQUFFLE1BQU0sQUFDcEIsQ0FBQyxBQUVPLE9BQU8sQUFBRSxDQUFDLEFBQ2YsVUFBVSxDQUFFLE1BQU0sQ0FDbEIsV0FBVyxVQUFVLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUN4RCxPQUFPLENBQUUsQ0FBQyxBQUNiLENBQUMsaUJBRUoiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQXhlcy5zdmVsdGUiXX0= */');
}
var get_box_slot_changes = (dirty) => ({});
var get_box_slot_context = (ctx) => ({});
var get_yaxis_slot_changes = (dirty) => ({});
var get_yaxis_slot_context = (ctx) => ({});
var get_xaxis_slot_changes = (dirty) => ({});
var get_xaxis_slot_context = (ctx) => ({});
function create_if_block_3(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      attr_dev(div, "class", "axes__title svelte-1z0dyat");
      add_location(div, file, 362, 21, 13451);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      div.innerHTML = ctx[0];
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 1)
        div.innerHTML = ctx2[0];
      ;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: '(363:3) {#if title !== \\"\\"}',
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let div;
  let span;
  const block = {
    c: function create() {
      div = element("div");
      span = element("span");
      attr_dev(span, "class", "svelte-1z0dyat");
      add_location(span, file, 363, 48, 13549);
      attr_dev(div, "class", "axes__ylabel svelte-1z0dyat");
      add_location(div, file, 363, 22, 13523);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, span);
      span.innerHTML = ctx[2];
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 4)
        span.innerHTML = ctx2[2];
      ;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: '(364:3) {#if yLabel !== \\"\\"}',
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let div;
  let span;
  const block = {
    c: function create() {
      div = element("div");
      span = element("span");
      attr_dev(span, "class", "svelte-1z0dyat");
      add_location(span, file, 364, 48, 13636);
      attr_dev(div, "class", "axes__xlabel svelte-1z0dyat");
      add_location(div, file, 364, 22, 13610);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, span);
      span.innerHTML = ctx[1];
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 2)
        span.innerHTML = ctx2[1];
      ;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: '(365:3) {#if xLabel !== \\"\\"}',
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let p;
  let t0;
  let br;
  let t1;
  const block = {
    c: function create() {
      p = element("p");
      t0 = text("Axes component was not properly initialized. ");
      br = element("br");
      t1 = text("\n      Add plot series (check that coordinates are numeric) or define axes limits manually.");
      attr_dev(br, "class", "svelte-1z0dyat");
      add_location(br, file, 392, 51, 14566);
      attr_dev(p, "class", "message_error svelte-1z0dyat");
      add_location(p, file, 391, 3, 14489);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
      append_dev(p, t0);
      append_dev(p, br);
      append_dev(p, t1);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(p);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(391:3) {#if !$isOk}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let div1;
  let t0;
  let t1;
  let t2;
  let div0;
  let svg;
  let defs;
  let clipPath;
  let rect;
  let rect_x_value;
  let rect_y_value;
  let rect_width_value;
  let rect_height_value;
  let g;
  let g_clip_path_value;
  let t3;
  let div1_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[0] !== "" && create_if_block_3(ctx);
  let if_block1 = ctx[2] !== "" && create_if_block_2(ctx);
  let if_block2 = ctx[1] !== "" && create_if_block_1(ctx);
  const xaxis_slot_template = ctx[27].xaxis;
  const xaxis_slot = create_slot(xaxis_slot_template, ctx, ctx[26], get_xaxis_slot_context);
  const yaxis_slot_template = ctx[27].yaxis;
  const yaxis_slot = create_slot(yaxis_slot_template, ctx, ctx[26], get_yaxis_slot_context);
  const default_slot_template = ctx[27].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[26], null);
  const box_slot_template = ctx[27].box;
  const box_slot = create_slot(box_slot_template, ctx, ctx[26], get_box_slot_context);
  let if_block3 = !ctx[3] && create_if_block(ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      div0 = element("div");
      svg = svg_element("svg");
      defs = svg_element("defs");
      clipPath = svg_element("clipPath");
      rect = svg_element("rect");
      if (xaxis_slot)
        xaxis_slot.c();
      if (yaxis_slot)
        yaxis_slot.c();
      g = svg_element("g");
      if (default_slot)
        default_slot.c();
      if (box_slot)
        box_slot.c();
      t3 = space();
      if (if_block3)
        if_block3.c();
      set_style(rect, "pointer-events", "none");
      attr_dev(rect, "x", rect_x_value = ctx[8][0]);
      attr_dev(rect, "y", rect_y_value = ctx[7][1]);
      attr_dev(rect, "width", rect_width_value = ctx[8][1] - ctx[8][0]);
      attr_dev(rect, "height", rect_height_value = ctx[7][0] - ctx[7][1]);
      attr_dev(rect, "class", "svelte-1z0dyat");
      add_location(rect, file, 373, 15, 13980);
      attr_dev(clipPath, "id", ctx[9]);
      attr_dev(clipPath, "class", "svelte-1z0dyat");
      add_location(clipPath, file, 372, 12, 13936);
      attr_dev(defs, "class", "svelte-1z0dyat");
      add_location(defs, file, 371, 9, 13917);
      attr_dev(g, "class", "axes-content svelte-1z0dyat");
      attr_dev(g, "clip-path", g_clip_path_value = "url(#" + ctx[9] + ")");
      add_location(g, file, 382, 9, 14294);
      attr_dev(svg, "preserveAspectRatio", "none");
      attr_dev(svg, "class", "axes svelte-1z0dyat");
      add_location(svg, file, 368, 6, 13774);
      attr_dev(div0, "class", "axes-wrapper svelte-1z0dyat");
      add_location(div0, file, 367, 3, 13716);
      attr_dev(div1, "class", div1_class_value = "plot " + ("plot_" + ctx[4]) + " svelte-1z0dyat");
      toggle_class(div1, "plot_error", !ctx[3]);
      add_location(div1, file, 359, 0, 13299);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      if (if_block0)
        if_block0.m(div1, null);
      append_dev(div1, t0);
      if (if_block1)
        if_block1.m(div1, null);
      append_dev(div1, t1);
      if (if_block2)
        if_block2.m(div1, null);
      append_dev(div1, t2);
      append_dev(div1, div0);
      append_dev(div0, svg);
      append_dev(svg, defs);
      append_dev(defs, clipPath);
      append_dev(clipPath, rect);
      if (xaxis_slot) {
        xaxis_slot.m(svg, null);
      }
      if (yaxis_slot) {
        yaxis_slot.m(svg, null);
      }
      append_dev(svg, g);
      if (default_slot) {
        default_slot.m(g, null);
      }
      if (box_slot) {
        box_slot.m(svg, null);
      }
      append_dev(div0, t3);
      if (if_block3)
        if_block3.m(div0, null);
      ctx[28](div0);
      ctx[29](div1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(svg, "click", ctx[16], false, false, false),
          listen_dev(svg, "keydown", ctx[16], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (ctx2[0] !== "") {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_3(ctx2);
          if_block0.c();
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[2] !== "") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_2(ctx2);
          if_block1.c();
          if_block1.m(div1, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (ctx2[1] !== "") {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_1(ctx2);
          if_block2.c();
          if_block2.m(div1, t2);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (!current || dirty[0] & 256 && rect_x_value !== (rect_x_value = ctx2[8][0])) {
        attr_dev(rect, "x", rect_x_value);
      }
      if (!current || dirty[0] & 128 && rect_y_value !== (rect_y_value = ctx2[7][1])) {
        attr_dev(rect, "y", rect_y_value);
      }
      if (!current || dirty[0] & 256 && rect_width_value !== (rect_width_value = ctx2[8][1] - ctx2[8][0])) {
        attr_dev(rect, "width", rect_width_value);
      }
      if (!current || dirty[0] & 128 && rect_height_value !== (rect_height_value = ctx2[7][0] - ctx2[7][1])) {
        attr_dev(rect, "height", rect_height_value);
      }
      if (xaxis_slot) {
        if (xaxis_slot.p && (!current || dirty[0] & 67108864)) {
          update_slot_base(
            xaxis_slot,
            xaxis_slot_template,
            ctx2,
            ctx2[26],
            !current ? get_all_dirty_from_scope(ctx2[26]) : get_slot_changes(xaxis_slot_template, ctx2[26], dirty, get_xaxis_slot_changes),
            get_xaxis_slot_context
          );
        }
      }
      if (yaxis_slot) {
        if (yaxis_slot.p && (!current || dirty[0] & 67108864)) {
          update_slot_base(
            yaxis_slot,
            yaxis_slot_template,
            ctx2,
            ctx2[26],
            !current ? get_all_dirty_from_scope(ctx2[26]) : get_slot_changes(yaxis_slot_template, ctx2[26], dirty, get_yaxis_slot_changes),
            get_yaxis_slot_context
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & 67108864)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[26],
            !current ? get_all_dirty_from_scope(ctx2[26]) : get_slot_changes(default_slot_template, ctx2[26], dirty, null),
            null
          );
        }
      }
      if (box_slot) {
        if (box_slot.p && (!current || dirty[0] & 67108864)) {
          update_slot_base(
            box_slot,
            box_slot_template,
            ctx2,
            ctx2[26],
            !current ? get_all_dirty_from_scope(ctx2[26]) : get_slot_changes(box_slot_template, ctx2[26], dirty, get_box_slot_changes),
            get_box_slot_context
          );
        }
      }
      if (!ctx2[3]) {
        if (if_block3) {
        } else {
          if_block3 = create_if_block(ctx2);
          if_block3.c();
          if_block3.m(div0, null);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (!current || dirty[0] & 16 && div1_class_value !== (div1_class_value = "plot " + ("plot_" + ctx2[4]) + " svelte-1z0dyat")) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty[0] & 24) {
        toggle_class(div1, "plot_error", !ctx2[3]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(xaxis_slot, local);
      transition_in(yaxis_slot, local);
      transition_in(default_slot, local);
      transition_in(box_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(xaxis_slot, local);
      transition_out(yaxis_slot, local);
      transition_out(default_slot, local);
      transition_out(box_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (xaxis_slot)
        xaxis_slot.d(detaching);
      if (yaxis_slot)
        yaxis_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      if (box_slot)
        box_slot.d(detaching);
      if (if_block3)
        if_block3.d();
      ctx[28](null);
      ctx[29](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function niceNum(localRange, round) {
  const exponent = Math.floor(Math.log10(localRange));
  const fraction = localRange / Math.pow(10, exponent);
  let niceFraction;
  if (round) {
    if (fraction < 1.5)
      niceFraction = 1;
    else if (fraction < 3)
      niceFraction = 2;
    else if (fraction < 7)
      niceFraction = 5;
    else
      niceFraction = 10;
  } else {
    if (fraction <= 1)
      niceFraction = 1;
    else if (fraction <= 2)
      niceFraction = 2;
    else if (fraction <= 5)
      niceFraction = 5;
    else
      niceFraction = 10;
  }
  return niceFraction * Math.pow(10, exponent);
}
function getScale(width, height) {
  if (height < 300.2 || width < 300.2)
    return "small";
  if (height < 600.2 || width < 600.2)
    return "medium";
  return "large";
}
function instance($$self, $$props, $$invalidate) {
  let margins;
  let cpx;
  let cpy;
  let $height;
  let $yLim;
  let $isOk;
  let $width;
  let $xLim;
  let $scale;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Axes", slots, ["xaxis", "yaxis", "default", "box"]);
  let { limX = [void 0, void 0] } = $$props;
  let { limY = [void 0, void 0] } = $$props;
  let { title = "" } = $$props;
  let { xLabel = "" } = $$props;
  let { yLabel = "" } = $$props;
  let { multiSeries = true } = $$props;
  const dispatch = createEventDispatcher();
  const AXES_MARGIN_FACTORS = { "small": 30, "medium": 40, "large": 50 };
  const TICK_NUM = { "small": 5, "medium": 8, "large": 12 };
  const LABELS_MARGIN = { "small": 10, "medium": 15, "large": 20 };
  const LINE_STYLES = {
    small: ["0", "3,3", "1,1", "3,1"],
    medium: ["0", "5,5", "2,2", "5,2"],
    large: ["0", "7,7", "3,3", "7,3"]
  };
  const clipPathID = "plottingArea" + Math.round(Math.random() * 1e4);
  let plotElement;
  let axesElement;
  let axesMargins = [0.034, 0.034, 0.034, 0.034];
  const width = writable(100);
  validate_store(width, "width");
  component_subscribe($$self, width, (value) => $$invalidate(24, $width = value));
  const height = writable(100);
  validate_store(height, "height");
  component_subscribe($$self, height, (value) => $$invalidate(22, $height = value));
  const xLim = writable([void 0, void 0]);
  validate_store(xLim, "xLim");
  component_subscribe($$self, xLim, (value) => $$invalidate(25, $xLim = value));
  const yLim = writable([void 0, void 0]);
  validate_store(yLim, "yLim");
  component_subscribe($$self, yLim, (value) => $$invalidate(23, $yLim = value));
  const scale = writable("medium");
  validate_store(scale, "scale");
  component_subscribe($$self, scale, (value) => $$invalidate(4, $scale = value));
  const isOk = writable(false);
  validate_store(isOk, "isOk");
  component_subscribe($$self, isOk, (value) => $$invalidate(3, $isOk = value));
  const addXAxisMargins = function() {
    $$invalidate(20, axesMargins[0] = 1, axesMargins);
    $$invalidate(20, axesMargins[2] = 0.5, axesMargins);
    $$invalidate(20, axesMargins[1] = axesMargins[1] > 0.5 ? axesMargins[1] : 0.5, axesMargins);
    $$invalidate(20, axesMargins[3] = axesMargins[3] > 0.5 ? axesMargins[3] : 0.5, axesMargins);
  };
  const addYAxisMargins = function() {
    $$invalidate(20, axesMargins[1] = 1, axesMargins);
    $$invalidate(20, axesMargins[3] = 0.5, axesMargins);
    $$invalidate(20, axesMargins[0] = axesMargins[0] > 0.5 ? axesMargins[0] : 0.5, axesMargins);
    $$invalidate(20, axesMargins[2] = axesMargins[2] > 0.5 ? axesMargins[2] : 0.5, axesMargins);
  };
  const adjustXAxisLimits = function(newLim) {
    if (!limX.some((v) => v === void 0))
      return;
    xLim.update((lim) => adjustAxisLimits(lim, newLim));
  };
  const adjustYAxisLimits = function(newLim) {
    if (!limY.some((v) => v === void 0))
      return;
    yLim.update((lim) => adjustAxisLimits(lim, newLim));
  };
  const adjustAxisLimits = function(lim, newLim) {
    let adjustedLim = [
      lim[0] !== void 0 && multiSeries === true && lim[0] < newLim[0] ? lim[0] : newLim[0],
      lim[1] !== void 0 && multiSeries === true && lim[1] > newLim[1] ? lim[1] : newLim[1]
    ];
    if (adjustedLim[0] === 0 && adjustedLim[1] === 0) {
      adjustedLim = [-0.1, 0.1];
    }
    if (adjustedLim[0] === adjustedLim[1]) {
      adjustedLim = [adjustedLim[0] * 0.95, adjustedLim[0] * 1.05];
    }
    return adjustedLim;
  };
  const roundCoords = function(x) {
    return Math.round(x * 10) / 10;
  };
  const scaleX = function(x, xLim2, width2, doSizeScale = false) {
    if (!$isOk || x === void 0 || !Array.isArray(x))
      return void 0;
    if (doSizeScale) {
      return x.map((v) => roundCoords(v / (xLim2[1] - xLim2[0]) * (width2 - margins[1] - margins[3])));
    }
    return x.map((v) => roundCoords((v - xLim2[0]) / (xLim2[1] - xLim2[0]) * (width2 - margins[1] - margins[3]) + margins[1]));
  };
  const scaleY = function(y, yLim2, height2, doSizeScale = false) {
    if (!$isOk || y === void 0 || !Array.isArray(y))
      return void 0;
    if (doSizeScale) {
      return y.map((v) => roundCoords(v / (yLim2[1] - yLim2[0]) * (height2 - margins[0] - margins[2])));
    }
    return y.map((v) => roundCoords((yLim2[1] - v) / (yLim2[1] - yLim2[0]) * (height2 - margins[0] - margins[2]) + margins[2]));
  };
  const getAxisTicks = function(ticks, lim, maxTickNum, round = true) {
    if (ticks !== void 0)
      return ticks;
    if (!Array.isArray(lim) || lim[0] === void 0 || lim[1] === void 0)
      return void 0;
    const range = niceNum(lim[1] - lim[0], round);
    const tickSpacing = niceNum(range / (maxTickNum - 1), round);
    const tickMin = Math.ceil(lim[0] / tickSpacing) * tickSpacing;
    const tickMax = Math.floor(lim[1] / tickSpacing) * tickSpacing;
    maxTickNum = Math.round((tickMax - tickMin + 1) / tickSpacing) + 1;
    ticks = [...Array(maxTickNum)].map((x, i) => tickMin + i * tickSpacing);
    if (Math.abs(tickSpacing) < 1) {
      const r = Math.pow(10, 1 + Math.round(-Math.log10(tickSpacing)));
      ticks = ticks.map((v) => Math.round((v + Number.EPSILON) * r) / r);
    }
    return ticks.filter((x) => x >= lim[0] & x <= lim[1]);
  };
  let context = {
    addXAxisMargins,
    addYAxisMargins,
    adjustXAxisLimits,
    adjustYAxisLimits,
    getAxisTicks,
    scaleX,
    scaleY,
    isOk,
    scale,
    width,
    height,
    xLim,
    yLim,
    LINE_STYLES,
    LABELS_MARGIN,
    TICK_NUM
  };
  setContext("axes", context);
  function dispatchClickEvent(eventName, el) {
    dispatch(eventName, {
      seriesTitle: el.parentNode.getAttribute("title"),
      elementID: el.dataset.id
    });
  }
  function handleClick(e) {
    if (e.target.tagName === "text" && e.target.parentNode.classList.contains("series_scatter")) {
      dispatchClickEvent("markerclick", e.target);
      return;
    }
    if (e.target.tagName === "rect" && e.target.parentNode.classList.contains("series_bar")) {
      dispatchClickEvent("barclick", e.target);
      return;
    }
    dispatch("axesclick");
  }
  const ro2 = new ResizeObserver((entries) => {
    for (let entry of entries) {
      const acr = axesElement.getBoundingClientRect();
      width.update((x) => acr.width);
      height.update((x) => acr.height);
    }
  });
  const ro1 = new ResizeObserver((entries) => {
    for (let entry of entries) {
      const pcr = plotElement.getBoundingClientRect();
      scale.update((x) => getScale(pcr.width, pcr.height));
    }
  });
  onMount(() => {
    ro1.observe(plotElement);
    ro2.observe(axesElement);
  });
  onDestroy(() => {
    ro1.unobserve(plotElement);
    ro2.unobserve(axesElement);
  });
  const writable_props = ["limX", "limY", "title", "xLabel", "yLabel", "multiSeries"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Axes> was created with unknown prop '${key}'`);
  });
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      axesElement = $$value;
      $$invalidate(6, axesElement);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      plotElement = $$value;
      $$invalidate(5, plotElement);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("limX" in $$props2)
      $$invalidate(17, limX = $$props2.limX);
    if ("limY" in $$props2)
      $$invalidate(18, limY = $$props2.limY);
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("xLabel" in $$props2)
      $$invalidate(1, xLabel = $$props2.xLabel);
    if ("yLabel" in $$props2)
      $$invalidate(2, yLabel = $$props2.yLabel);
    if ("multiSeries" in $$props2)
      $$invalidate(19, multiSeries = $$props2.multiSeries);
    if ("$$scope" in $$props2)
      $$invalidate(26, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    setContext,
    createEventDispatcher,
    onMount,
    onDestroy,
    writable,
    limX,
    limY,
    title,
    xLabel,
    yLabel,
    multiSeries,
    dispatch,
    AXES_MARGIN_FACTORS,
    TICK_NUM,
    LABELS_MARGIN,
    LINE_STYLES,
    clipPathID,
    plotElement,
    axesElement,
    axesMargins,
    width,
    height,
    xLim,
    yLim,
    scale,
    isOk,
    addXAxisMargins,
    addYAxisMargins,
    adjustXAxisLimits,
    adjustYAxisLimits,
    adjustAxisLimits,
    roundCoords,
    scaleX,
    scaleY,
    getAxisTicks,
    niceNum,
    getScale,
    context,
    dispatchClickEvent,
    handleClick,
    ro2,
    ro1,
    cpy,
    cpx,
    margins,
    $height,
    $yLim,
    $isOk,
    $width,
    $xLim,
    $scale
  });
  $$self.$inject_state = ($$props2) => {
    if ("limX" in $$props2)
      $$invalidate(17, limX = $$props2.limX);
    if ("limY" in $$props2)
      $$invalidate(18, limY = $$props2.limY);
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("xLabel" in $$props2)
      $$invalidate(1, xLabel = $$props2.xLabel);
    if ("yLabel" in $$props2)
      $$invalidate(2, yLabel = $$props2.yLabel);
    if ("multiSeries" in $$props2)
      $$invalidate(19, multiSeries = $$props2.multiSeries);
    if ("plotElement" in $$props2)
      $$invalidate(5, plotElement = $$props2.plotElement);
    if ("axesElement" in $$props2)
      $$invalidate(6, axesElement = $$props2.axesElement);
    if ("axesMargins" in $$props2)
      $$invalidate(20, axesMargins = $$props2.axesMargins);
    if ("context" in $$props2)
      context = $$props2.context;
    if ("cpy" in $$props2)
      $$invalidate(7, cpy = $$props2.cpy);
    if ("cpx" in $$props2)
      $$invalidate(8, cpx = $$props2.cpx);
    if ("margins" in $$props2)
      $$invalidate(21, margins = $$props2.margins);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 131072) {
      $:
        if (!limX.some((v) => v === void 0))
          xLim.update((v) => limX);
    }
    if ($$self.$$.dirty[0] & 262144) {
      $:
        if (!limY.some((v) => v === void 0))
          yLim.update((v) => limY);
    }
    if ($$self.$$.dirty[0] & 1048592) {
      $:
        $$invalidate(21, margins = axesMargins.map((v) => v * AXES_MARGIN_FACTORS[$scale]));
    }
    if ($$self.$$.dirty[0] & 65011712) {
      $:
        isOk.update((v) => Array.isArray($yLim) && Array.isArray($xLim) && $xLim.length === 2 && $yLim.length === 2 && !$yLim.some((v2) => v2 === void 0) && !$xLim.some((v2) => v2 === void 0) && !$yLim.some((v2) => isNaN(v2)) && !$xLim.some((v2) => isNaN(v2)) && $xLim[1] !== $xLim[0] && $yLim[1] !== $yLim[0] && $width > margins[1] + margins[3] && $height > margins[0] + margins[2]);
    }
    if ($$self.$$.dirty[0] & 50331656) {
      $:
        $$invalidate(8, cpx = $isOk ? scaleX($xLim, $xLim, $width) : [0, 1]);
    }
    if ($$self.$$.dirty[0] & 12582920) {
      $:
        $$invalidate(7, cpy = $isOk ? scaleY($yLim, $yLim, $height) : [1, 0]);
    }
  };
  return [
    title,
    xLabel,
    yLabel,
    $isOk,
    $scale,
    plotElement,
    axesElement,
    cpy,
    cpx,
    clipPathID,
    width,
    height,
    xLim,
    yLim,
    scale,
    isOk,
    handleClick,
    limX,
    limY,
    multiSeries,
    axesMargins,
    margins,
    $height,
    $yLim,
    $width,
    $xLim,
    $$scope,
    slots,
    div0_binding,
    div1_binding
  ];
}
var Axes = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        limX: 17,
        limY: 18,
        title: 0,
        xLabel: 1,
        yLabel: 2,
        multiSeries: 19
      },
      add_css,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Axes",
      options,
      id: create_fragment.name
    });
  }
  get limX() {
    throw new Error("<Axes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set limX(value) {
    throw new Error("<Axes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get limY() {
    throw new Error("<Axes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set limY(value) {
    throw new Error("<Axes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Axes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Axes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xLabel() {
    throw new Error("<Axes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xLabel(value) {
    throw new Error("<Axes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yLabel() {
    throw new Error("<Axes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yLabel(value) {
    throw new Error("<Axes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multiSeries() {
    throw new Error("<Axes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiSeries(value) {
    throw new Error("<Axes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Axes_default = Axes;

// node_modules/svelte-plots-basic/src/Colors.js
var Colors = {
  "AXIS_LINE": "#303030",
  "AXIS_TICK": "#606060",
  "WHITE": "#fff",
  "BLACK": "#000",
  "GRAY": "#909090",
  "MIDDLEGRAY": "#dadada",
  "LIGHTGRAY": "#f0f0f0",
  "DARKGRAY": "#606060",
  "PRIMARY": "#2266ff",
  "PRIMARY_TEXT": "#333"
};

// node_modules/svelte-plots-basic/src/XAxis.svelte
var file2 = "node_modules/svelte-plots-basic/src/XAxis.svelte";
function add_css2(target) {
  append_styles(target, "svelte-1qspqf3", ".svelte-1qspqf3{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiWEF4aXMuc3ZlbHRlIiwibWFwcGluZ3MiOiJpQkFvRUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiWEF4aXMuc3ZlbHRlIl19 */");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[26] = list[i];
  child_ctx[28] = i;
  return child_ctx;
}
function create_if_block2(ctx) {
  let g;
  let line;
  let line_x__value;
  let line_x__value_1;
  let line_y__value;
  let line_y__value_1;
  let each_value = ctx[4];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      g = svg_element("g");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      line = svg_element("line");
      attr_dev(line, "x1", line_x__value = ctx[5][0]);
      attr_dev(line, "x2", line_x__value_1 = ctx[5][1]);
      attr_dev(line, "y1", line_y__value = ctx[2][0]);
      attr_dev(line, "y2", line_y__value_1 = ctx[2][0]);
      attr_dev(line, "style", ctx[7]);
      attr_dev(line, "class", "svelte-1qspqf3");
      add_location(line, file2, 63, 3, 2597);
      attr_dev(g, "class", "mdaplot__axis mdaplot__xaxis svelte-1qspqf3");
      add_location(g, file2, 57, 3, 2169);
    },
    m: function mount(target, anchor) {
      insert_dev(target, g, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(g, null);
      }
      append_dev(g, line);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 415) {
        each_value = ctx2[4];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(g, line);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 32 && line_x__value !== (line_x__value = ctx2[5][0])) {
        attr_dev(line, "x1", line_x__value);
      }
      if (dirty & 32 && line_x__value_1 !== (line_x__value_1 = ctx2[5][1])) {
        attr_dev(line, "x2", line_x__value_1);
      }
      if (dirty & 4 && line_y__value !== (line_y__value = ctx2[2][0])) {
        attr_dev(line, "y1", line_y__value);
      }
      if (dirty & 4 && line_y__value_1 !== (line_y__value_1 = ctx2[2][0])) {
        attr_dev(line, "y2", line_y__value_1);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(g);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(57:0) {#if $isOk && x !== undefined && y !== undefined }",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let line0;
  let line0_x__value;
  let line0_x__value_1;
  let line0_y__value;
  let line0_y__value_1;
  let line1;
  let line1_x__value;
  let line1_x__value_1;
  let line1_y__value;
  let line1_y__value_1;
  let text_1;
  let t_value = ctx[0][ctx[28]] + "";
  let t;
  let text_1_x_value;
  let text_1_y_value;
  const block = {
    c: function create() {
      line0 = svg_element("line");
      line1 = svg_element("line");
      text_1 = svg_element("text");
      t = text(t_value);
      attr_dev(line0, "x1", line0_x__value = ctx[26]);
      attr_dev(line0, "x2", line0_x__value_1 = ctx[26]);
      attr_dev(line0, "y1", line0_y__value = ctx[2][0]);
      attr_dev(line0, "y2", line0_y__value_1 = ctx[2][1]);
      attr_dev(line0, "style", ctx[8]);
      attr_dev(line0, "class", "svelte-1qspqf3");
      add_location(line0, file2, 59, 6, 2243);
      attr_dev(line1, "x1", line1_x__value = ctx[26]);
      attr_dev(line1, "x2", line1_x__value_1 = ctx[26]);
      attr_dev(line1, "y1", line1_y__value = ctx[3][0]);
      attr_dev(line1, "y2", line1_y__value_1 = ctx[3][1]);
      attr_dev(line1, "style", ctx[7]);
      attr_dev(line1, "class", "svelte-1qspqf3");
      add_location(line1, file2, 60, 6, 2334);
      attr_dev(text_1, "x", text_1_x_value = ctx[26]);
      attr_dev(text_1, "y", text_1_y_value = ctx[3][1]);
      attr_dev(text_1, "dx", "0");
      attr_dev(text_1, "dy", ctx[1]);
      attr_dev(text_1, "class", "mdaplot__axis-labels svelte-1qspqf3");
      attr_dev(text_1, "dominant-baseline", "middle");
      attr_dev(text_1, "text-anchor", "middle");
      add_location(text_1, file2, 61, 6, 2435);
    },
    m: function mount(target, anchor) {
      insert_dev(target, line0, anchor);
      insert_dev(target, line1, anchor);
      insert_dev(target, text_1, anchor);
      append_dev(text_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 16 && line0_x__value !== (line0_x__value = ctx2[26])) {
        attr_dev(line0, "x1", line0_x__value);
      }
      if (dirty & 16 && line0_x__value_1 !== (line0_x__value_1 = ctx2[26])) {
        attr_dev(line0, "x2", line0_x__value_1);
      }
      if (dirty & 4 && line0_y__value !== (line0_y__value = ctx2[2][0])) {
        attr_dev(line0, "y1", line0_y__value);
      }
      if (dirty & 4 && line0_y__value_1 !== (line0_y__value_1 = ctx2[2][1])) {
        attr_dev(line0, "y2", line0_y__value_1);
      }
      if (dirty & 16 && line1_x__value !== (line1_x__value = ctx2[26])) {
        attr_dev(line1, "x1", line1_x__value);
      }
      if (dirty & 16 && line1_x__value_1 !== (line1_x__value_1 = ctx2[26])) {
        attr_dev(line1, "x2", line1_x__value_1);
      }
      if (dirty & 8 && line1_y__value !== (line1_y__value = ctx2[3][0])) {
        attr_dev(line1, "y1", line1_y__value);
      }
      if (dirty & 8 && line1_y__value_1 !== (line1_y__value_1 = ctx2[3][1])) {
        attr_dev(line1, "y2", line1_y__value_1);
      }
      if (dirty & 1 && t_value !== (t_value = ctx2[0][ctx2[28]] + ""))
        set_data_dev(t, t_value);
      if (dirty & 16 && text_1_x_value !== (text_1_x_value = ctx2[26])) {
        attr_dev(text_1, "x", text_1_x_value);
      }
      if (dirty & 8 && text_1_y_value !== (text_1_y_value = ctx2[3][1])) {
        attr_dev(text_1, "y", text_1_y_value);
      }
      if (dirty & 2) {
        attr_dev(text_1, "dy", ctx2[1]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(line0);
      if (detaching)
        detach_dev(line1);
      if (detaching)
        detach_dev(text_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(59:3) {#each ticksX as tx, i}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let if_block_anchor;
  let if_block = ctx[6] && ctx[5] !== void 0 && ctx[2] !== void 0 && create_if_block2(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[6] && ctx2[5] !== void 0 && ctx2[2] !== void 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let x;
  let y;
  let dy;
  let tickNum;
  let ticksX;
  let ticksY;
  let $axesWidth;
  let $xLim;
  let $scale;
  let $axesHeight;
  let $yLim;
  let $isOk;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("XAxis", slots, []);
  let { slot = "xaxis" } = $$props;
  let { ticks = void 0 } = $$props;
  let { tickLabels = ticks } = $$props;
  let { showGrid = false } = $$props;
  const tickMode = ticks === void 0 ? "auto" : "manual";
  if (slot !== "xaxis") {
    throw `Component XAxis must have "slot='xaxis'" attribute.`;
  }
  if (ticks !== void 0 && !Array.isArray(ticks)) {
    throw "XAxis: 'ticks' must be a vector of numbers.";
  }
  if (ticks !== void 0 && !(Array.isArray(tickLabels) && tickLabels.length == ticks.length)) {
    throw "XAxis: 'tickLabels' must be a vector of the same size as ticks.";
  }
  const axisLineStyleStr = `stroke:${Colors.DARKGRAY};line-width:1px;`;
  const gridLineStyleStr = `stroke:${Colors.MIDDLEGRAY};stroke-opacity:${showGrid ? 1 : 0};stroke-dasharray:2px;`;
  const axes = getContext("axes");
  axes.addXAxisMargins();
  const xLim = axes.xLim;
  validate_store(xLim, "xLim");
  component_subscribe($$self, xLim, (value) => $$invalidate(20, $xLim = value));
  const yLim = axes.yLim;
  validate_store(yLim, "yLim");
  component_subscribe($$self, yLim, (value) => $$invalidate(23, $yLim = value));
  const axesWidth = axes.width;
  validate_store(axesWidth, "axesWidth");
  component_subscribe($$self, axesWidth, (value) => $$invalidate(19, $axesWidth = value));
  const axesHeight = axes.height;
  validate_store(axesHeight, "axesHeight");
  component_subscribe($$self, axesHeight, (value) => $$invalidate(22, $axesHeight = value));
  const scale = axes.scale;
  validate_store(scale, "scale");
  component_subscribe($$self, scale, (value) => $$invalidate(21, $scale = value));
  const isOk = axes.isOk;
  validate_store(isOk, "isOk");
  component_subscribe($$self, isOk, (value) => $$invalidate(6, $isOk = value));
  const writable_props = ["slot", "ticks", "tickLabels", "showGrid"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<XAxis> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("slot" in $$props2)
      $$invalidate(16, slot = $$props2.slot);
    if ("ticks" in $$props2)
      $$invalidate(15, ticks = $$props2.ticks);
    if ("tickLabels" in $$props2)
      $$invalidate(0, tickLabels = $$props2.tickLabels);
    if ("showGrid" in $$props2)
      $$invalidate(17, showGrid = $$props2.showGrid);
  };
  $$self.$capture_state = () => ({
    getContext,
    Colors,
    slot,
    ticks,
    tickLabels,
    showGrid,
    tickMode,
    axisLineStyleStr,
    gridLineStyleStr,
    axes,
    xLim,
    yLim,
    axesWidth,
    axesHeight,
    scale,
    isOk,
    dy,
    y,
    ticksY,
    ticksX,
    tickNum,
    x,
    $axesWidth,
    $xLim,
    $scale,
    $axesHeight,
    $yLim,
    $isOk
  });
  $$self.$inject_state = ($$props2) => {
    if ("slot" in $$props2)
      $$invalidate(16, slot = $$props2.slot);
    if ("ticks" in $$props2)
      $$invalidate(15, ticks = $$props2.ticks);
    if ("tickLabels" in $$props2)
      $$invalidate(0, tickLabels = $$props2.tickLabels);
    if ("showGrid" in $$props2)
      $$invalidate(17, showGrid = $$props2.showGrid);
    if ("dy" in $$props2)
      $$invalidate(1, dy = $$props2.dy);
    if ("y" in $$props2)
      $$invalidate(2, y = $$props2.y);
    if ("ticksY" in $$props2)
      $$invalidate(3, ticksY = $$props2.ticksY);
    if ("ticksX" in $$props2)
      $$invalidate(4, ticksX = $$props2.ticksX);
    if ("tickNum" in $$props2)
      $$invalidate(18, tickNum = $$props2.tickNum);
    if ("x" in $$props2)
      $$invalidate(5, x = $$props2.x);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1572864) {
      $:
        $$invalidate(5, x = axes.scaleX($xLim, $xLim, $axesWidth));
    }
    if ($$self.$$.dirty & 12582912) {
      $:
        $$invalidate(2, y = axes.scaleY($yLim, $yLim, $axesHeight));
    }
    if ($$self.$$.dirty & 2097152) {
      $:
        $$invalidate(1, dy = $scale === "small" ? 7 : 10);
    }
    if ($$self.$$.dirty & 2097152) {
      $:
        $$invalidate(18, tickNum = axes.TICK_NUM[$scale]);
    }
    if ($$self.$$.dirty & 1343488) {
      $:
        $$invalidate(15, ticks = tickMode === "auto" ? axes.getAxisTicks(void 0, $xLim, tickNum, true) : ticks);
    }
    if ($$self.$$.dirty & 32769) {
      $:
        $$invalidate(0, tickLabels = tickMode === "auto" ? ticks : tickLabels);
    }
    if ($$self.$$.dirty & 1605632) {
      $:
        $$invalidate(4, ticksX = axes.scaleX(ticks, $xLim, $axesWidth));
    }
    if ($$self.$$.dirty & 6) {
      $:
        $$invalidate(3, ticksY = y === void 0 ? void 0 : [y[0], y[0] + dy]);
    }
  };
  return [
    tickLabels,
    dy,
    y,
    ticksY,
    ticksX,
    x,
    $isOk,
    axisLineStyleStr,
    gridLineStyleStr,
    xLim,
    yLim,
    axesWidth,
    axesHeight,
    scale,
    isOk,
    ticks,
    slot,
    showGrid,
    tickNum,
    $axesWidth,
    $xLim,
    $scale,
    $axesHeight,
    $yLim
  ];
}
var XAxis = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance2,
      create_fragment2,
      safe_not_equal,
      {
        slot: 16,
        ticks: 15,
        tickLabels: 0,
        showGrid: 17
      },
      add_css2
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "XAxis",
      options,
      id: create_fragment2.name
    });
  }
  get slot() {
    throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slot(value) {
    throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ticks() {
    throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ticks(value) {
    throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tickLabels() {
    throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tickLabels(value) {
    throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showGrid() {
    throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showGrid(value) {
    throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var XAxis_default = XAxis;

// node_modules/svelte-plots-basic/src/YAxis.svelte
var file3 = "node_modules/svelte-plots-basic/src/YAxis.svelte";
function add_css3(target) {
  append_styles(target, "svelte-1qspqf3", ".svelte-1qspqf3{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiWUF4aXMuc3ZlbHRlIiwibWFwcGluZ3MiOiJpQkF1RUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiWUF4aXMuc3ZlbHRlIl19 */");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[26] = list[i];
  child_ctx[28] = i;
  return child_ctx;
}
function create_if_block3(ctx) {
  let g;
  let line;
  let line_x__value;
  let line_x__value_1;
  let line_y__value;
  let line_y__value_1;
  let each_value = ctx[4];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      g = svg_element("g");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      line = svg_element("line");
      attr_dev(line, "x1", line_x__value = ctx[1][0]);
      attr_dev(line, "x2", line_x__value_1 = ctx[1][0]);
      attr_dev(line, "y1", line_y__value = ctx[5][0]);
      attr_dev(line, "y2", line_y__value_1 = ctx[5][1]);
      attr_dev(line, "style", ctx[7]);
      attr_dev(line, "class", "svelte-1qspqf3");
      add_location(line, file3, 66, 3, 2703);
      attr_dev(g, "class", "mdaplot__axis mdaplot__yaxis svelte-1qspqf3");
      add_location(g, file3, 60, 3, 2240);
    },
    m: function mount(target, anchor) {
      insert_dev(target, g, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(g, null);
      }
      append_dev(g, line);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 479) {
        each_value = ctx2[4];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(g, line);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 2 && line_x__value !== (line_x__value = ctx2[1][0])) {
        attr_dev(line, "x1", line_x__value);
      }
      if (dirty & 2 && line_x__value_1 !== (line_x__value_1 = ctx2[1][0])) {
        attr_dev(line, "x2", line_x__value_1);
      }
      if (dirty & 32 && line_y__value !== (line_y__value = ctx2[5][0])) {
        attr_dev(line, "y1", line_y__value);
      }
      if (dirty & 32 && line_y__value_1 !== (line_y__value_1 = ctx2[5][1])) {
        attr_dev(line, "y2", line_y__value_1);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(g);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(60:0) {#if x !== undefined && y !== undefined }",
    ctx
  });
  return block;
}
function create_each_block2(ctx) {
  let line0;
  let line0_x__value;
  let line0_x__value_1;
  let line0_y__value;
  let line0_y__value_1;
  let line1;
  let line1_x__value;
  let line1_x__value_1;
  let line1_y__value;
  let line1_y__value_1;
  let text_1;
  let t_value = ctx[0][ctx[28]] + "";
  let t;
  let text_1_x_value;
  let text_1_y_value;
  let text_1_dy_value;
  const block = {
    c: function create() {
      line0 = svg_element("line");
      line1 = svg_element("line");
      text_1 = svg_element("text");
      t = text(t_value);
      attr_dev(line0, "x1", line0_x__value = ctx[1][0]);
      attr_dev(line0, "x2", line0_x__value_1 = ctx[1][1]);
      attr_dev(line0, "y1", line0_y__value = ctx[26]);
      attr_dev(line0, "y2", line0_y__value_1 = ctx[26]);
      attr_dev(line0, "style", ctx[8]);
      attr_dev(line0, "class", "svelte-1qspqf3");
      add_location(line0, file3, 62, 6, 2314);
      attr_dev(line1, "x1", line1_x__value = ctx[3][0]);
      attr_dev(line1, "x2", line1_x__value_1 = ctx[3][1]);
      attr_dev(line1, "y1", line1_y__value = ctx[26]);
      attr_dev(line1, "y2", line1_y__value_1 = ctx[26]);
      attr_dev(line1, "style", ctx[7]);
      attr_dev(line1, "class", "svelte-1qspqf3");
      add_location(line1, file3, 63, 6, 2405);
      attr_dev(text_1, "x", text_1_x_value = ctx[3][0]);
      attr_dev(text_1, "y", text_1_y_value = ctx[26]);
      attr_dev(text_1, "dx", ctx[2]);
      attr_dev(text_1, "dy", text_1_dy_value = 0);
      attr_dev(text_1, "transform", ctx[6]);
      set_style(text_1, "background", "red");
      attr_dev(text_1, "class", "mdaplot__axis-labels svelte-1qspqf3");
      attr_dev(text_1, "dominant-baseline", "middle");
      attr_dev(text_1, "text-anchor", "end");
      add_location(text_1, file3, 64, 6, 2507);
    },
    m: function mount(target, anchor) {
      insert_dev(target, line0, anchor);
      insert_dev(target, line1, anchor);
      insert_dev(target, text_1, anchor);
      append_dev(text_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2 && line0_x__value !== (line0_x__value = ctx2[1][0])) {
        attr_dev(line0, "x1", line0_x__value);
      }
      if (dirty & 2 && line0_x__value_1 !== (line0_x__value_1 = ctx2[1][1])) {
        attr_dev(line0, "x2", line0_x__value_1);
      }
      if (dirty & 16 && line0_y__value !== (line0_y__value = ctx2[26])) {
        attr_dev(line0, "y1", line0_y__value);
      }
      if (dirty & 16 && line0_y__value_1 !== (line0_y__value_1 = ctx2[26])) {
        attr_dev(line0, "y2", line0_y__value_1);
      }
      if (dirty & 8 && line1_x__value !== (line1_x__value = ctx2[3][0])) {
        attr_dev(line1, "x1", line1_x__value);
      }
      if (dirty & 8 && line1_x__value_1 !== (line1_x__value_1 = ctx2[3][1])) {
        attr_dev(line1, "x2", line1_x__value_1);
      }
      if (dirty & 16 && line1_y__value !== (line1_y__value = ctx2[26])) {
        attr_dev(line1, "y1", line1_y__value);
      }
      if (dirty & 16 && line1_y__value_1 !== (line1_y__value_1 = ctx2[26])) {
        attr_dev(line1, "y2", line1_y__value_1);
      }
      if (dirty & 1 && t_value !== (t_value = ctx2[0][ctx2[28]] + ""))
        set_data_dev(t, t_value);
      if (dirty & 8 && text_1_x_value !== (text_1_x_value = ctx2[3][0])) {
        attr_dev(text_1, "x", text_1_x_value);
      }
      if (dirty & 16 && text_1_y_value !== (text_1_y_value = ctx2[26])) {
        attr_dev(text_1, "y", text_1_y_value);
      }
      if (dirty & 4) {
        attr_dev(text_1, "dx", ctx2[2]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(line0);
      if (detaching)
        detach_dev(line1);
      if (detaching)
        detach_dev(text_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(62:3) {#each ticksY as ty, i}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let if_block_anchor;
  let if_block = ctx[1] !== void 0 && ctx[5] !== void 0 && create_if_block3(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1] !== void 0 && ctx2[5] !== void 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let x;
  let y;
  let dx;
  let tickNum;
  let ticksY;
  let ticksX;
  let $axesHeight;
  let $yLim;
  let $scale;
  let $axesWidth;
  let $xLim;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("YAxis", slots, []);
  let { slot = "yaxis" } = $$props;
  let { ticks = void 0 } = $$props;
  let { tickLabels = ticks } = $$props;
  let { showGrid = false } = $$props;
  let { las = 1 } = $$props;
  const tickMode = ticks === void 0 ? "auto" : "manual";
  const transform = las > 1 ? "" : "";
  if (slot !== "yaxis") {
    throw `Component YAxis must have "slot='yaxis'" attribute.`;
  }
  if (ticks !== void 0 && !Array.isArray(ticks)) {
    throw "YAxis: 'ticks' must be a vector of numbers.";
  }
  if (ticks !== void 0 && !(Array.isArray(tickLabels) && tickLabels.length == ticks.length)) {
    throw "YAxis: 'tickLabels' must be a vector of the same size as ticks.";
  }
  const axisLineStyleStr = `stroke:${Colors.DARKGRAY};line-width:1px;`;
  const gridLineStyleStr = `stroke:${Colors.MIDDLEGRAY};stroke-opacity:${showGrid ? 1 : 0};stroke-dasharray:2px;`;
  const axes = getContext("axes");
  axes.addYAxisMargins();
  const xLim = axes.xLim;
  validate_store(xLim, "xLim");
  component_subscribe($$self, xLim, (value) => $$invalidate(23, $xLim = value));
  const yLim = axes.yLim;
  validate_store(yLim, "yLim");
  component_subscribe($$self, yLim, (value) => $$invalidate(20, $yLim = value));
  const axesWidth = axes.width;
  validate_store(axesWidth, "axesWidth");
  component_subscribe($$self, axesWidth, (value) => $$invalidate(22, $axesWidth = value));
  const axesHeight = axes.height;
  validate_store(axesHeight, "axesHeight");
  component_subscribe($$self, axesHeight, (value) => $$invalidate(19, $axesHeight = value));
  const scale = axes.scale;
  validate_store(scale, "scale");
  component_subscribe($$self, scale, (value) => $$invalidate(21, $scale = value));
  const writable_props = ["slot", "ticks", "tickLabels", "showGrid", "las"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<YAxis> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("slot" in $$props2)
      $$invalidate(15, slot = $$props2.slot);
    if ("ticks" in $$props2)
      $$invalidate(14, ticks = $$props2.ticks);
    if ("tickLabels" in $$props2)
      $$invalidate(0, tickLabels = $$props2.tickLabels);
    if ("showGrid" in $$props2)
      $$invalidate(16, showGrid = $$props2.showGrid);
    if ("las" in $$props2)
      $$invalidate(17, las = $$props2.las);
  };
  $$self.$capture_state = () => ({
    getContext,
    Colors,
    slot,
    ticks,
    tickLabels,
    showGrid,
    las,
    tickMode,
    transform,
    axisLineStyleStr,
    gridLineStyleStr,
    axes,
    xLim,
    yLim,
    axesWidth,
    axesHeight,
    scale,
    x,
    dx,
    ticksX,
    ticksY,
    tickNum,
    y,
    $axesHeight,
    $yLim,
    $scale,
    $axesWidth,
    $xLim
  });
  $$self.$inject_state = ($$props2) => {
    if ("slot" in $$props2)
      $$invalidate(15, slot = $$props2.slot);
    if ("ticks" in $$props2)
      $$invalidate(14, ticks = $$props2.ticks);
    if ("tickLabels" in $$props2)
      $$invalidate(0, tickLabels = $$props2.tickLabels);
    if ("showGrid" in $$props2)
      $$invalidate(16, showGrid = $$props2.showGrid);
    if ("las" in $$props2)
      $$invalidate(17, las = $$props2.las);
    if ("x" in $$props2)
      $$invalidate(1, x = $$props2.x);
    if ("dx" in $$props2)
      $$invalidate(2, dx = $$props2.dx);
    if ("ticksX" in $$props2)
      $$invalidate(3, ticksX = $$props2.ticksX);
    if ("ticksY" in $$props2)
      $$invalidate(4, ticksY = $$props2.ticksY);
    if ("tickNum" in $$props2)
      $$invalidate(18, tickNum = $$props2.tickNum);
    if ("y" in $$props2)
      $$invalidate(5, y = $$props2.y);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 12582912) {
      $:
        $$invalidate(1, x = axes.scaleX($xLim, $xLim, $axesWidth));
    }
    if ($$self.$$.dirty & 1572864) {
      $:
        $$invalidate(5, y = axes.scaleY($yLim, $yLim, $axesHeight));
    }
    if ($$self.$$.dirty & 2097152) {
      $:
        $$invalidate(2, dx = $scale === "small" ? -4 : -6);
    }
    if ($$self.$$.dirty & 2097152) {
      $:
        $$invalidate(18, tickNum = axes.TICK_NUM[$scale]);
    }
    if ($$self.$$.dirty & 1327104) {
      $:
        $$invalidate(14, ticks = tickMode === "auto" ? axes.getAxisTicks(void 0, $yLim, tickNum, true) : ticks);
    }
    if ($$self.$$.dirty & 16385) {
      $:
        $$invalidate(0, tickLabels = tickMode === "auto" ? ticks : tickLabels);
    }
    if ($$self.$$.dirty & 1589248) {
      $:
        $$invalidate(4, ticksY = axes.scaleY(ticks, $yLim, $axesHeight));
    }
    if ($$self.$$.dirty & 6) {
      $:
        $$invalidate(3, ticksX = x === void 0 ? void 0 : [x[0] + dx, x[0]]);
    }
  };
  return [
    tickLabels,
    x,
    dx,
    ticksX,
    ticksY,
    y,
    transform,
    axisLineStyleStr,
    gridLineStyleStr,
    xLim,
    yLim,
    axesWidth,
    axesHeight,
    scale,
    ticks,
    slot,
    showGrid,
    las,
    tickNum,
    $axesHeight,
    $yLim,
    $scale,
    $axesWidth,
    $xLim
  ];
}
var YAxis = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance3,
      create_fragment3,
      safe_not_equal,
      {
        slot: 15,
        ticks: 14,
        tickLabels: 0,
        showGrid: 16,
        las: 17
      },
      add_css3
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "YAxis",
      options,
      id: create_fragment3.name
    });
  }
  get slot() {
    throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slot(value) {
    throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ticks() {
    throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ticks(value) {
    throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tickLabels() {
    throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tickLabels(value) {
    throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showGrid() {
    throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showGrid(value) {
    throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get las() {
    throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set las(value) {
    throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var YAxis_default = YAxis;

// node_modules/svelte-plots-basic/src/Rectangles.svelte
var file4 = "node_modules/svelte-plots-basic/src/Rectangles.svelte";
function add_css4(target) {
  append_styles(target, "svelte-1qspqf3", ".svelte-1qspqf3{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmVjdGFuZ2xlcy5zdmVsdGUiLCJtYXBwaW5ncyI6ImlCQStEQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJSZWN0YW5nbGVzLnN2ZWx0ZSJdfQ== */");
}
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[25] = list[i];
  child_ctx[27] = i;
  return child_ctx;
}
function create_if_block4(ctx) {
  let g;
  let g_class_value;
  let each_value = ctx[0];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      g = svg_element("g");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr_dev(g, "class", g_class_value = "series " + ctx[2] + " svelte-1qspqf3");
      attr_dev(g, "title", ctx[1]);
      attr_dev(g, "style", ctx[3]);
      add_location(g, file4, 55, 3, 2003);
    },
    m: function mount(target, anchor) {
      insert_dev(target, g, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(g, null);
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & 241) {
        each_value = ctx2[0];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(g, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 4 && g_class_value !== (g_class_value = "series " + ctx2[2] + " svelte-1qspqf3")) {
        attr_dev(g, "class", g_class_value);
      }
      if (dirty & 2) {
        attr_dev(g, "title", ctx2[1]);
      }
      if (dirty & 8) {
        attr_dev(g, "style", ctx2[3]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(g);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(55:0) {#if rx !== undefined && ry !== undefined}",
    ctx
  });
  return block;
}
function create_each_block3(ctx) {
  let rect;
  let rect_x_value;
  let rect_y_value;
  let rect_width_value;
  let rect_height_value;
  const block = {
    c: function create() {
      rect = svg_element("rect");
      attr_dev(rect, "x", rect_x_value = ctx[7][ctx[27]]);
      attr_dev(rect, "y", rect_y_value = ctx[6][ctx[27]]);
      attr_dev(rect, "width", rect_width_value = ctx[5][ctx[27]]);
      attr_dev(rect, "height", rect_height_value = ctx[4][ctx[27]]);
      attr_dev(rect, "class", "svelte-1qspqf3");
      add_location(rect, file4, 57, 6, 2095);
    },
    m: function mount(target, anchor) {
      insert_dev(target, rect, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 128 && rect_x_value !== (rect_x_value = ctx2[7][ctx2[27]])) {
        attr_dev(rect, "x", rect_x_value);
      }
      if (dirty & 64 && rect_y_value !== (rect_y_value = ctx2[6][ctx2[27]])) {
        attr_dev(rect, "y", rect_y_value);
      }
      if (dirty & 32 && rect_width_value !== (rect_width_value = ctx2[5][ctx2[27]])) {
        attr_dev(rect, "width", rect_width_value);
      }
      if (dirty & 16 && rect_height_value !== (rect_height_value = ctx2[4][ctx2[27]])) {
        attr_dev(rect, "height", rect_height_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(rect);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block3.name,
    type: "each",
    source: "(57:3) {#each left as v, i}",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let if_block_anchor;
  let if_block = ctx[7] !== void 0 && ctx[6] !== void 0 && create_if_block4(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[7] !== void 0 && ctx2[6] !== void 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block4(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let rx;
  let ry;
  let rw;
  let rh;
  let barsStyleStr;
  let $axesHeight;
  let $yLim;
  let $axesWidth;
  let $xLim;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Rectangles", slots, []);
  let { left } = $$props;
  let { top } = $$props;
  let { width } = $$props;
  let { height } = $$props;
  let { labels = void 0 } = $$props;
  let { faceColor = Colors.PRIMARY } = $$props;
  let { borderColor = faceColor } = $$props;
  let { lineWidth = 1 } = $$props;
  let { title = "" } = $$props;
  let { style = "series_rect" } = $$props;
  if (!Array.isArray(left) || !Array.isArray(top) || left.length < 1 || left.length != top.length) {
    throw "Rectangles: parameters 'left' and 'top' must be vectors of the same size.";
  }
  const n = left.length;
  if (!Array.isArray(height))
    height = Array(n).fill(height);
  if (!Array.isArray(width))
    width = Array(n).fill(width);
  if (top.length !== n || width.length !== n || height.length !== n) {
    throw "Rectangles: x, y, w and h should have the same length (w and h can be single values).";
  }
  if (labels !== void 0 && (!Array.isArray(labels) || labels.length !== n)) {
    throw "Rectangles: vector with labels should have the same length as vectors with x and y coordinates.";
  }
  const axes = getContext("axes");
  const xLim = axes.xLim;
  validate_store(xLim, "xLim");
  component_subscribe($$self, xLim, (value) => $$invalidate(22, $xLim = value));
  const yLim = axes.yLim;
  validate_store(yLim, "yLim");
  component_subscribe($$self, yLim, (value) => $$invalidate(20, $yLim = value));
  const axesWidth = axes.width;
  validate_store(axesWidth, "axesWidth");
  component_subscribe($$self, axesWidth, (value) => $$invalidate(21, $axesWidth = value));
  const axesHeight = axes.height;
  validate_store(axesHeight, "axesHeight");
  component_subscribe($$self, axesHeight, (value) => $$invalidate(19, $axesHeight = value));
  $$self.$$.on_mount.push(function() {
    if (left === void 0 && !("left" in $$props || $$self.$$.bound[$$self.$$.props["left"]])) {
      console.warn("<Rectangles> was created without expected prop 'left'");
    }
    if (top === void 0 && !("top" in $$props || $$self.$$.bound[$$self.$$.props["top"]])) {
      console.warn("<Rectangles> was created without expected prop 'top'");
    }
    if (width === void 0 && !("width" in $$props || $$self.$$.bound[$$self.$$.props["width"]])) {
      console.warn("<Rectangles> was created without expected prop 'width'");
    }
    if (height === void 0 && !("height" in $$props || $$self.$$.bound[$$self.$$.props["height"]])) {
      console.warn("<Rectangles> was created without expected prop 'height'");
    }
  });
  const writable_props = [
    "left",
    "top",
    "width",
    "height",
    "labels",
    "faceColor",
    "borderColor",
    "lineWidth",
    "title",
    "style"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Rectangles> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("left" in $$props2)
      $$invalidate(0, left = $$props2.left);
    if ("top" in $$props2)
      $$invalidate(14, top = $$props2.top);
    if ("width" in $$props2)
      $$invalidate(12, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(13, height = $$props2.height);
    if ("labels" in $$props2)
      $$invalidate(15, labels = $$props2.labels);
    if ("faceColor" in $$props2)
      $$invalidate(16, faceColor = $$props2.faceColor);
    if ("borderColor" in $$props2)
      $$invalidate(17, borderColor = $$props2.borderColor);
    if ("lineWidth" in $$props2)
      $$invalidate(18, lineWidth = $$props2.lineWidth);
    if ("title" in $$props2)
      $$invalidate(1, title = $$props2.title);
    if ("style" in $$props2)
      $$invalidate(2, style = $$props2.style);
  };
  $$self.$capture_state = () => ({
    getContext,
    Colors,
    left,
    top,
    width,
    height,
    labels,
    faceColor,
    borderColor,
    lineWidth,
    title,
    style,
    n,
    axes,
    xLim,
    yLim,
    axesWidth,
    axesHeight,
    barsStyleStr,
    rh,
    rw,
    ry,
    rx,
    $axesHeight,
    $yLim,
    $axesWidth,
    $xLim
  });
  $$self.$inject_state = ($$props2) => {
    if ("left" in $$props2)
      $$invalidate(0, left = $$props2.left);
    if ("top" in $$props2)
      $$invalidate(14, top = $$props2.top);
    if ("width" in $$props2)
      $$invalidate(12, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(13, height = $$props2.height);
    if ("labels" in $$props2)
      $$invalidate(15, labels = $$props2.labels);
    if ("faceColor" in $$props2)
      $$invalidate(16, faceColor = $$props2.faceColor);
    if ("borderColor" in $$props2)
      $$invalidate(17, borderColor = $$props2.borderColor);
    if ("lineWidth" in $$props2)
      $$invalidate(18, lineWidth = $$props2.lineWidth);
    if ("title" in $$props2)
      $$invalidate(1, title = $$props2.title);
    if ("style" in $$props2)
      $$invalidate(2, style = $$props2.style);
    if ("barsStyleStr" in $$props2)
      $$invalidate(3, barsStyleStr = $$props2.barsStyleStr);
    if ("rh" in $$props2)
      $$invalidate(4, rh = $$props2.rh);
    if ("rw" in $$props2)
      $$invalidate(5, rw = $$props2.rw);
    if ("ry" in $$props2)
      $$invalidate(6, ry = $$props2.ry);
    if ("rx" in $$props2)
      $$invalidate(7, rx = $$props2.rx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 6291457) {
      $:
        $$invalidate(7, rx = axes.scaleX(left, $xLim, $axesWidth));
    }
    if ($$self.$$.dirty & 1589248) {
      $:
        $$invalidate(6, ry = axes.scaleY(top, $yLim, $axesHeight));
    }
    if ($$self.$$.dirty & 6295552) {
      $:
        $$invalidate(5, rw = axes.scaleX(width, $xLim, $axesWidth, true));
    }
    if ($$self.$$.dirty & 1581056) {
      $:
        $$invalidate(4, rh = axes.scaleY(height, $yLim, $axesHeight, true));
    }
    if ($$self.$$.dirty & 458752) {
      $:
        $$invalidate(3, barsStyleStr = `fill:${faceColor};stroke:${borderColor};stroke-width:${lineWidth}px;`);
    }
  };
  return [
    left,
    title,
    style,
    barsStyleStr,
    rh,
    rw,
    ry,
    rx,
    xLim,
    yLim,
    axesWidth,
    axesHeight,
    width,
    height,
    top,
    labels,
    faceColor,
    borderColor,
    lineWidth,
    $axesHeight,
    $yLim,
    $axesWidth,
    $xLim
  ];
}
var Rectangles = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance4,
      create_fragment4,
      safe_not_equal,
      {
        left: 0,
        top: 14,
        width: 12,
        height: 13,
        labels: 15,
        faceColor: 16,
        borderColor: 17,
        lineWidth: 18,
        title: 1,
        style: 2
      },
      add_css4
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Rectangles",
      options,
      id: create_fragment4.name
    });
  }
  get left() {
    throw new Error("<Rectangles>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set left(value) {
    throw new Error("<Rectangles>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get top() {
    throw new Error("<Rectangles>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set top(value) {
    throw new Error("<Rectangles>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Rectangles>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Rectangles>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Rectangles>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Rectangles>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labels() {
    throw new Error("<Rectangles>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labels(value) {
    throw new Error("<Rectangles>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get faceColor() {
    throw new Error("<Rectangles>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set faceColor(value) {
    throw new Error("<Rectangles>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderColor() {
    throw new Error("<Rectangles>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderColor(value) {
    throw new Error("<Rectangles>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineWidth() {
    throw new Error("<Rectangles>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineWidth(value) {
    throw new Error("<Rectangles>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Rectangles>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Rectangles>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Rectangles>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Rectangles>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Rectangles_default = Rectangles;

// node_modules/svelte-plots-basic/src/Box.svelte
var file5 = "node_modules/svelte-plots-basic/src/Box.svelte";
function add_css5(target) {
  append_styles(target, "svelte-1qspqf3", ".svelte-1qspqf3{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQm94LnN2ZWx0ZSIsIm1hcHBpbmdzIjoiaUJBa0NBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkJveC5zdmVsdGUiXX0= */");
}
function create_if_block5(ctx) {
  let g;
  let rectangles;
  let current;
  rectangles = new Rectangles_default({
    props: {
      left: ctx[3],
      top: ctx[2],
      width: ctx[1],
      height: ctx[0],
      borderColor: Colors.DARKGRAY,
      faceColor: "transparent"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      g = svg_element("g");
      create_component(rectangles.$$.fragment);
      set_style(g, "pointer-events", "none");
      attr_dev(g, "class", "mdaplot__axes-box svelte-1qspqf3");
      add_location(g, file5, 28, 3, 744);
    },
    m: function mount(target, anchor) {
      insert_dev(target, g, anchor);
      mount_component(rectangles, g, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const rectangles_changes = {};
      if (dirty & 8)
        rectangles_changes.left = ctx2[3];
      if (dirty & 4)
        rectangles_changes.top = ctx2[2];
      if (dirty & 2)
        rectangles_changes.width = ctx2[1];
      if (dirty & 1)
        rectangles_changes.height = ctx2[0];
      rectangles.$set(rectangles_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(rectangles.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(rectangles.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(g);
      destroy_component(rectangles);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(28:0) {#if $isOk}",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[4] && create_if_block5(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[4]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block5(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let left;
  let top;
  let width;
  let height;
  let $yLim;
  let $xLim;
  let $isOk;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Box", slots, []);
  let { slot } = $$props;
  if (slot !== "box") {
    throw `Component Box must have "slot='box'" attribute.`;
  }
  const axes = getContext("axes");
  const xLim = axes.xLim;
  validate_store(xLim, "xLim");
  component_subscribe($$self, xLim, (value) => $$invalidate(10, $xLim = value));
  const yLim = axes.yLim;
  validate_store(yLim, "yLim");
  component_subscribe($$self, yLim, (value) => $$invalidate(9, $yLim = value));
  const isOk = axes.isOk;
  validate_store(isOk, "isOk");
  component_subscribe($$self, isOk, (value) => $$invalidate(4, $isOk = value));
  $$self.$$.on_mount.push(function() {
    if (slot === void 0 && !("slot" in $$props || $$self.$$.bound[$$self.$$.props["slot"]])) {
      console.warn("<Box> was created without expected prop 'slot'");
    }
  });
  const writable_props = ["slot"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Box> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("slot" in $$props2)
      $$invalidate(8, slot = $$props2.slot);
  };
  $$self.$capture_state = () => ({
    getContext,
    Colors,
    Rectangles: Rectangles_default,
    slot,
    axes,
    xLim,
    yLim,
    isOk,
    height,
    width,
    top,
    left,
    $yLim,
    $xLim,
    $isOk
  });
  $$self.$inject_state = ($$props2) => {
    if ("slot" in $$props2)
      $$invalidate(8, slot = $$props2.slot);
    if ("height" in $$props2)
      $$invalidate(0, height = $$props2.height);
    if ("width" in $$props2)
      $$invalidate(1, width = $$props2.width);
    if ("top" in $$props2)
      $$invalidate(2, top = $$props2.top);
    if ("left" in $$props2)
      $$invalidate(3, left = $$props2.left);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1024) {
      $:
        $$invalidate(3, left = [$xLim[0]]);
    }
    if ($$self.$$.dirty & 512) {
      $:
        $$invalidate(2, top = [$yLim[1]]);
    }
    if ($$self.$$.dirty & 1024) {
      $:
        $$invalidate(1, width = [$xLim[1] - $xLim[0]]);
    }
    if ($$self.$$.dirty & 512) {
      $:
        $$invalidate(0, height = [$yLim[1] - $yLim[0]]);
    }
  };
  return [height, width, top, left, $isOk, xLim, yLim, isOk, slot, $yLim, $xLim];
}
var Box = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { slot: 8 }, add_css5);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Box",
      options,
      id: create_fragment5.name
    });
  }
  get slot() {
    throw new Error("<Box>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slot(value) {
    throw new Error("<Box>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Box_default = Box;

// node_modules/svelte-plots-basic/src/Segments.svelte
var file6 = "node_modules/svelte-plots-basic/src/Segments.svelte";
function add_css6(target) {
  append_styles(target, "svelte-1qspqf3", ".svelte-1qspqf3{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2VnbWVudHMuc3ZlbHRlIiwibWFwcGluZ3MiOiJpQkFtREEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiU2VnbWVudHMuc3ZlbHRlIl19 */");
}
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[26] = list[i];
  child_ctx[28] = i;
  return child_ctx;
}
function create_if_block6(ctx) {
  let g;
  let g_class_value;
  let each_value = ctx[6];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block4(get_each_context4(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      g = svg_element("g");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr_dev(g, "class", g_class_value = "series " + ctx[1] + " svelte-1qspqf3");
      attr_dev(g, "title", ctx[0]);
      attr_dev(g, "style", ctx[2]);
      add_location(g, file6, 43, 3, 1553);
    },
    m: function mount(target, anchor) {
      insert_dev(target, g, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(g, null);
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & 120) {
        each_value = ctx2[6];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block4(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(g, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 2 && g_class_value !== (g_class_value = "series " + ctx2[1] + " svelte-1qspqf3")) {
        attr_dev(g, "class", g_class_value);
      }
      if (dirty & 1) {
        attr_dev(g, "title", ctx2[0]);
      }
      if (dirty & 4) {
        attr_dev(g, "style", ctx2[2]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(g);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block6.name,
    type: "if",
    source: "(43:0) {#if x1 !== undefined && y1 !== undefined}",
    ctx
  });
  return block;
}
function create_each_block4(ctx) {
  let line;
  let line_x__value;
  let line_x__value_1;
  let line_y__value;
  let line_y__value_1;
  const block = {
    c: function create() {
      line = svg_element("line");
      attr_dev(line, "x1", line_x__value = ctx[6][ctx[28]]);
      attr_dev(line, "x2", line_x__value_1 = ctx[5][ctx[28]]);
      attr_dev(line, "y1", line_y__value = ctx[4][ctx[28]]);
      attr_dev(line, "y2", line_y__value_1 = ctx[3][ctx[28]]);
      attr_dev(line, "class", "svelte-1qspqf3");
      add_location(line, file6, 45, 6, 1643);
    },
    m: function mount(target, anchor) {
      insert_dev(target, line, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 64 && line_x__value !== (line_x__value = ctx2[6][ctx2[28]])) {
        attr_dev(line, "x1", line_x__value);
      }
      if (dirty & 32 && line_x__value_1 !== (line_x__value_1 = ctx2[5][ctx2[28]])) {
        attr_dev(line, "x2", line_x__value_1);
      }
      if (dirty & 16 && line_y__value !== (line_y__value = ctx2[4][ctx2[28]])) {
        attr_dev(line, "y1", line_y__value);
      }
      if (dirty & 8 && line_y__value_1 !== (line_y__value_1 = ctx2[3][ctx2[28]])) {
        attr_dev(line, "y2", line_y__value_1);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block4.name,
    type: "each",
    source: "(45:3) {#each x1 as v, i}",
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let if_block_anchor;
  let if_block = ctx[6] !== void 0 && ctx[4] !== void 0 && create_if_block6(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[6] !== void 0 && ctx2[4] !== void 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block6(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let x1;
  let x2;
  let y1;
  let y2;
  let lineStyleStr;
  let $scale;
  let $axesHeight;
  let $yLim;
  let $axesWidth;
  let $xLim;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Segments", slots, []);
  let { xStart } = $$props;
  let { xEnd } = $$props;
  let { yStart } = $$props;
  let { yEnd } = $$props;
  let { lineColor = Colors.PRIMARY } = $$props;
  let { lineType = 1 } = $$props;
  let { lineWidth = 1 } = $$props;
  let { title = "" } = $$props;
  let { style = "series_seg" } = $$props;
  if (!Array.isArray(xStart) || !Array.isArray(xEnd) || !Array.isArray(yStart) || !Array.isArray(yEnd)) {
    throw "Segments: parameters 'xStart', 'yStart', 'xEnd' and 'yEnd' must be vectors.";
  }
  const n = xStart.length;
  if (xEnd.length !== n || yStart.length !== n || yEnd.length !== n) {
    throw "Segments: parameters 'xStart', 'yStart', 'xEnd' and 'yEnd' should have the same length.";
  }
  const axes = getContext("axes");
  const xLim = axes.xLim;
  validate_store(xLim, "xLim");
  component_subscribe($$self, xLim, (value) => $$invalidate(23, $xLim = value));
  const yLim = axes.yLim;
  validate_store(yLim, "yLim");
  component_subscribe($$self, yLim, (value) => $$invalidate(21, $yLim = value));
  const axesWidth = axes.width;
  validate_store(axesWidth, "axesWidth");
  component_subscribe($$self, axesWidth, (value) => $$invalidate(22, $axesWidth = value));
  const axesHeight = axes.height;
  validate_store(axesHeight, "axesHeight");
  component_subscribe($$self, axesHeight, (value) => $$invalidate(20, $axesHeight = value));
  const scale = axes.scale;
  validate_store(scale, "scale");
  component_subscribe($$self, scale, (value) => $$invalidate(19, $scale = value));
  $$self.$$.on_mount.push(function() {
    if (xStart === void 0 && !("xStart" in $$props || $$self.$$.bound[$$self.$$.props["xStart"]])) {
      console.warn("<Segments> was created without expected prop 'xStart'");
    }
    if (xEnd === void 0 && !("xEnd" in $$props || $$self.$$.bound[$$self.$$.props["xEnd"]])) {
      console.warn("<Segments> was created without expected prop 'xEnd'");
    }
    if (yStart === void 0 && !("yStart" in $$props || $$self.$$.bound[$$self.$$.props["yStart"]])) {
      console.warn("<Segments> was created without expected prop 'yStart'");
    }
    if (yEnd === void 0 && !("yEnd" in $$props || $$self.$$.bound[$$self.$$.props["yEnd"]])) {
      console.warn("<Segments> was created without expected prop 'yEnd'");
    }
  });
  const writable_props = [
    "xStart",
    "xEnd",
    "yStart",
    "yEnd",
    "lineColor",
    "lineType",
    "lineWidth",
    "title",
    "style"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Segments> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("xStart" in $$props2)
      $$invalidate(12, xStart = $$props2.xStart);
    if ("xEnd" in $$props2)
      $$invalidate(13, xEnd = $$props2.xEnd);
    if ("yStart" in $$props2)
      $$invalidate(14, yStart = $$props2.yStart);
    if ("yEnd" in $$props2)
      $$invalidate(15, yEnd = $$props2.yEnd);
    if ("lineColor" in $$props2)
      $$invalidate(16, lineColor = $$props2.lineColor);
    if ("lineType" in $$props2)
      $$invalidate(17, lineType = $$props2.lineType);
    if ("lineWidth" in $$props2)
      $$invalidate(18, lineWidth = $$props2.lineWidth);
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("style" in $$props2)
      $$invalidate(1, style = $$props2.style);
  };
  $$self.$capture_state = () => ({
    getContext,
    Colors,
    xStart,
    xEnd,
    yStart,
    yEnd,
    lineColor,
    lineType,
    lineWidth,
    title,
    style,
    n,
    axes,
    xLim,
    yLim,
    axesWidth,
    axesHeight,
    scale,
    lineStyleStr,
    y2,
    y1,
    x2,
    x1,
    $scale,
    $axesHeight,
    $yLim,
    $axesWidth,
    $xLim
  });
  $$self.$inject_state = ($$props2) => {
    if ("xStart" in $$props2)
      $$invalidate(12, xStart = $$props2.xStart);
    if ("xEnd" in $$props2)
      $$invalidate(13, xEnd = $$props2.xEnd);
    if ("yStart" in $$props2)
      $$invalidate(14, yStart = $$props2.yStart);
    if ("yEnd" in $$props2)
      $$invalidate(15, yEnd = $$props2.yEnd);
    if ("lineColor" in $$props2)
      $$invalidate(16, lineColor = $$props2.lineColor);
    if ("lineType" in $$props2)
      $$invalidate(17, lineType = $$props2.lineType);
    if ("lineWidth" in $$props2)
      $$invalidate(18, lineWidth = $$props2.lineWidth);
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("style" in $$props2)
      $$invalidate(1, style = $$props2.style);
    if ("lineStyleStr" in $$props2)
      $$invalidate(2, lineStyleStr = $$props2.lineStyleStr);
    if ("y2" in $$props2)
      $$invalidate(3, y2 = $$props2.y2);
    if ("y1" in $$props2)
      $$invalidate(4, y1 = $$props2.y1);
    if ("x2" in $$props2)
      $$invalidate(5, x2 = $$props2.x2);
    if ("x1" in $$props2)
      $$invalidate(6, x1 = $$props2.x1);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 12587008) {
      $:
        $$invalidate(6, x1 = axes.scaleX(xStart, $xLim, $axesWidth));
    }
    if ($$self.$$.dirty & 12591104) {
      $:
        $$invalidate(5, x2 = axes.scaleX(xEnd, $xLim, $axesWidth));
    }
    if ($$self.$$.dirty & 3162112) {
      $:
        $$invalidate(4, y1 = axes.scaleY(yStart, $yLim, $axesHeight));
    }
    if ($$self.$$.dirty & 3178496) {
      $:
        $$invalidate(3, y2 = axes.scaleY(yEnd, $yLim, $axesHeight));
    }
    if ($$self.$$.dirty & 983040) {
      $:
        $$invalidate(2, lineStyleStr = `stroke:${lineColor};stroke-width: ${lineWidth}px;stroke-dasharray:${axes.LINE_STYLES[$scale][lineType - 1]}`);
    }
  };
  return [
    title,
    style,
    lineStyleStr,
    y2,
    y1,
    x2,
    x1,
    xLim,
    yLim,
    axesWidth,
    axesHeight,
    scale,
    xStart,
    xEnd,
    yStart,
    yEnd,
    lineColor,
    lineType,
    lineWidth,
    $scale,
    $axesHeight,
    $yLim,
    $axesWidth,
    $xLim
  ];
}
var Segments = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance6,
      create_fragment6,
      safe_not_equal,
      {
        xStart: 12,
        xEnd: 13,
        yStart: 14,
        yEnd: 15,
        lineColor: 16,
        lineType: 17,
        lineWidth: 18,
        title: 0,
        style: 1
      },
      add_css6
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Segments",
      options,
      id: create_fragment6.name
    });
  }
  get xStart() {
    throw new Error("<Segments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xStart(value) {
    throw new Error("<Segments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xEnd() {
    throw new Error("<Segments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xEnd(value) {
    throw new Error("<Segments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yStart() {
    throw new Error("<Segments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yStart(value) {
    throw new Error("<Segments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yEnd() {
    throw new Error("<Segments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yEnd(value) {
    throw new Error("<Segments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineColor() {
    throw new Error("<Segments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineColor(value) {
    throw new Error("<Segments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineType() {
    throw new Error("<Segments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineType(value) {
    throw new Error("<Segments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineWidth() {
    throw new Error("<Segments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineWidth(value) {
    throw new Error("<Segments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Segments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Segments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Segments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Segments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Segments_default = Segments;

// node_modules/mdatools/matrix/index.js
var times = (a, b) => a * b;
function vmult(x, y) {
  return vop(x, y, times);
}
function vop(x, y, op) {
  const n = x.length | y.length;
  if (n < 1) {
    throw Error("One of the arguments must be a vector.");
  }
  if (!isvector(y)) {
    y = rep(y, n);
  }
  if (!isvector(x)) {
    x = rep(x, n);
  }
  if (x.length !== y.length) {
    throw Error("Dimensions of 'x' and 'y' mismatch.");
  }
  let res = Array(n).fill(0);
  for (let i = 0; i < n; i++) {
    res[i] = op(x[i], y[i]);
  }
  return res;
}
function isvector(X) {
  if (!isarray(X))
    return false;
  if (Array.isArray(X[0]))
    return false;
  return true;
}
function isarray(X) {
  return Array.isArray(X) && X.length > 0;
}

// node_modules/svelte-plots-basic/src/TextLabels.svelte
var file7 = "node_modules/svelte-plots-basic/src/TextLabels.svelte";
function add_css7(target) {
  append_styles(target, "svelte-g0ius4", "text.svelte-g0ius4,text.svelte-g0ius4>tspan{cursor:default;user-select:none;dominant-baseline:middle}.svelte-g0ius4{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGV4dExhYmVscy5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBa0ZHLGtCQUFJLENBQUUsa0JBQUksQ0FBVyxLQUFLLEFBQUUsQ0FBQyxBQUMxQixNQUFNLENBQUUsT0FBTyxDQUNmLFdBQVcsQ0FBRSxJQUFJLENBQ2pCLGlCQUFpQixDQUFFLE1BQU0sQUFDNUIsQ0FBQyxnQkFDSiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJUZXh0TGFiZWxzLnN2ZWx0ZSJdfQ== */");
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[29] = list[i];
  child_ctx[31] = i;
  return child_ctx;
}
function get_each_context5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[29] = list[i];
  child_ctx[31] = i;
  return child_ctx;
}
function create_if_block7(ctx) {
  let g;
  let g_class_value;
  function select_block_type(ctx2, dirty) {
    if (ctx2[0] === 0)
      return create_if_block_12;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx, [-1, -1]);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      g = svg_element("g");
      if_block.c();
      attr_dev(g, "class", g_class_value = "series " + ctx[1] + " svelte-g0ius4");
      attr_dev(g, "title", ctx[2]);
      attr_dev(g, "style", ctx[3]);
      add_location(g, file7, 65, 3, 2576);
    },
    m: function mount(target, anchor) {
      insert_dev(target, g, anchor);
      if_block.m(g, null);
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(g, null);
        }
      }
      if (dirty[0] & 2 && g_class_value !== (g_class_value = "series " + ctx2[1] + " svelte-g0ius4")) {
        attr_dev(g, "class", g_class_value);
      }
      if (dirty[0] & 4) {
        attr_dev(g, "title", ctx2[2]);
      }
      if (dirty[0] & 8) {
        attr_dev(g, "style", ctx2[3]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(g);
      if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block7.name,
    type: "if",
    source: "(65:0) {#if x !== undefined && y !== undefined}",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let each_1_anchor;
  let each_value_1 = ctx[8];
  validate_each_argument(each_value_1);
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 1008) {
        each_value_1 = ctx2[8];
        validate_each_argument(each_value_1);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(73:3) {:else}",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let each_1_anchor;
  let each_value = ctx[8];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block5(get_each_context5(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 896) {
        each_value = ctx2[8];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context5(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block5(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(68:3) {#if pos === 0}",
    ctx
  });
  return block;
}
function create_each_block_1(ctx) {
  let text_1;
  let raw_value = ctx[9][ctx[31]] + "";
  let text_1_data_id_value;
  let text_1_x_value;
  let text_1_y_value;
  let text_1_dx_value;
  let text_1_dy_value;
  let text_1_text_anchor_value;
  const block = {
    c: function create() {
      text_1 = svg_element("text");
      attr_dev(text_1, "data-id", text_1_data_id_value = ctx[31]);
      attr_dev(text_1, "x", text_1_x_value = ctx[8][ctx[31]]);
      attr_dev(text_1, "y", text_1_y_value = ctx[7][ctx[31]]);
      attr_dev(text_1, "dx", text_1_dx_value = ctx[6][ctx[31]]);
      attr_dev(text_1, "dy", text_1_dy_value = ctx[5][ctx[31]]);
      attr_dev(text_1, "text-anchor", text_1_text_anchor_value = ctx[4][ctx[31]]);
      attr_dev(text_1, "class", "svelte-g0ius4");
      add_location(text_1, file7, 74, 6, 2802);
    },
    m: function mount(target, anchor) {
      insert_dev(target, text_1, anchor);
      text_1.innerHTML = raw_value;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 512 && raw_value !== (raw_value = ctx2[9][ctx2[31]] + ""))
        text_1.innerHTML = raw_value;
      ;
      if (dirty[0] & 256 && text_1_x_value !== (text_1_x_value = ctx2[8][ctx2[31]])) {
        attr_dev(text_1, "x", text_1_x_value);
      }
      if (dirty[0] & 128 && text_1_y_value !== (text_1_y_value = ctx2[7][ctx2[31]])) {
        attr_dev(text_1, "y", text_1_y_value);
      }
      if (dirty[0] & 64 && text_1_dx_value !== (text_1_dx_value = ctx2[6][ctx2[31]])) {
        attr_dev(text_1, "dx", text_1_dx_value);
      }
      if (dirty[0] & 32 && text_1_dy_value !== (text_1_dy_value = ctx2[5][ctx2[31]])) {
        attr_dev(text_1, "dy", text_1_dy_value);
      }
      if (dirty[0] & 16 && text_1_text_anchor_value !== (text_1_text_anchor_value = ctx2[4][ctx2[31]])) {
        attr_dev(text_1, "text-anchor", text_1_text_anchor_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(text_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(74:3) {#each x as v, i}",
    ctx
  });
  return block;
}
function create_each_block5(ctx) {
  let text_1;
  let raw_value = ctx[9][ctx[31]] + "";
  let text_1_data_id_value;
  let text_1_x_value;
  let text_1_y_value;
  const block = {
    c: function create() {
      text_1 = svg_element("text");
      attr_dev(text_1, "data-id", text_1_data_id_value = ctx[31]);
      attr_dev(text_1, "x", text_1_x_value = ctx[8][ctx[31]]);
      attr_dev(text_1, "y", text_1_y_value = ctx[7][ctx[31]]);
      attr_dev(text_1, "class", "svelte-g0ius4");
      add_location(text_1, file7, 69, 6, 2686);
    },
    m: function mount(target, anchor) {
      insert_dev(target, text_1, anchor);
      text_1.innerHTML = raw_value;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 512 && raw_value !== (raw_value = ctx2[9][ctx2[31]] + ""))
        text_1.innerHTML = raw_value;
      ;
      if (dirty[0] & 256 && text_1_x_value !== (text_1_x_value = ctx2[8][ctx2[31]])) {
        attr_dev(text_1, "x", text_1_x_value);
      }
      if (dirty[0] & 128 && text_1_y_value !== (text_1_y_value = ctx2[7][ctx2[31]])) {
        attr_dev(text_1, "y", text_1_y_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(text_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block5.name,
    type: "each",
    source: "(69:3) {#each x as v, i}",
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let if_block_anchor;
  let if_block = ctx[8] !== void 0 && ctx[7] !== void 0 && create_if_block7(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (ctx2[8] !== void 0 && ctx2[7] !== void 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block7(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function processValues(v, n, name) {
  if (!Array.isArray(v))
    return Array(n).fill(v);
  if (v.length !== n) {
    throw `TextLabels: parameter ${name} must be a single number or a vector of the same size as 'x' and 'y'.`;
  }
  return v;
}
function instance7($$self, $$props, $$invalidate) {
  let labelsLocal;
  let posLocal;
  let x;
  let y;
  let dx;
  let dy;
  let textAnchors;
  let textStyleStr;
  let $scale;
  let $axesHeight;
  let $yLim;
  let $axesWidth;
  let $xLim;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TextLabels", slots, []);
  let { xValues } = $$props;
  let { yValues } = $$props;
  let { labels } = $$props;
  let { pos = 0 } = $$props;
  let { faceColor = Colors.PRIMARY_TEXT } = $$props;
  let { borderColor = "transparent" } = $$props;
  let { borderWidth = 0 } = $$props;
  let { textSize = 1 } = $$props;
  let { style = "" } = $$props;
  let { title = "series_text" } = $$props;
  if (!Array.isArray(xValues) || !Array.isArray(yValues) || xValues.length !== yValues.length) {
    throw "TextLabels: parameters 'xValues' and 'yValues' must be vectors of the same length.";
  }
  const axes = getContext("axes");
  const xLim = axes.xLim;
  validate_store(xLim, "xLim");
  component_subscribe($$self, xLim, (value) => $$invalidate(27, $xLim = value));
  const yLim = axes.yLim;
  validate_store(yLim, "yLim");
  component_subscribe($$self, yLim, (value) => $$invalidate(25, $yLim = value));
  const axesWidth = axes.width;
  validate_store(axesWidth, "axesWidth");
  component_subscribe($$self, axesWidth, (value) => $$invalidate(26, $axesWidth = value));
  const axesHeight = axes.height;
  validate_store(axesHeight, "axesHeight");
  component_subscribe($$self, axesHeight, (value) => $$invalidate(24, $axesHeight = value));
  const scale = axes.scale;
  validate_store(scale, "scale");
  component_subscribe($$self, scale, (value) => $$invalidate(23, $scale = value));
  $$self.$$.on_mount.push(function() {
    if (xValues === void 0 && !("xValues" in $$props || $$self.$$.bound[$$self.$$.props["xValues"]])) {
      console.warn("<TextLabels> was created without expected prop 'xValues'");
    }
    if (yValues === void 0 && !("yValues" in $$props || $$self.$$.bound[$$self.$$.props["yValues"]])) {
      console.warn("<TextLabels> was created without expected prop 'yValues'");
    }
    if (labels === void 0 && !("labels" in $$props || $$self.$$.bound[$$self.$$.props["labels"]])) {
      console.warn("<TextLabels> was created without expected prop 'labels'");
    }
  });
  const writable_props = [
    "xValues",
    "yValues",
    "labels",
    "pos",
    "faceColor",
    "borderColor",
    "borderWidth",
    "textSize",
    "style",
    "title"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TextLabels> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("xValues" in $$props2)
      $$invalidate(15, xValues = $$props2.xValues);
    if ("yValues" in $$props2)
      $$invalidate(16, yValues = $$props2.yValues);
    if ("labels" in $$props2)
      $$invalidate(17, labels = $$props2.labels);
    if ("pos" in $$props2)
      $$invalidate(0, pos = $$props2.pos);
    if ("faceColor" in $$props2)
      $$invalidate(18, faceColor = $$props2.faceColor);
    if ("borderColor" in $$props2)
      $$invalidate(19, borderColor = $$props2.borderColor);
    if ("borderWidth" in $$props2)
      $$invalidate(20, borderWidth = $$props2.borderWidth);
    if ("textSize" in $$props2)
      $$invalidate(21, textSize = $$props2.textSize);
    if ("style" in $$props2)
      $$invalidate(1, style = $$props2.style);
    if ("title" in $$props2)
      $$invalidate(2, title = $$props2.title);
  };
  $$self.$capture_state = () => ({
    getContext,
    Colors,
    subset,
    vmult,
    xValues,
    yValues,
    labels,
    pos,
    faceColor,
    borderColor,
    borderWidth,
    textSize,
    style,
    title,
    processValues,
    axes,
    xLim,
    yLim,
    axesWidth,
    axesHeight,
    scale,
    textStyleStr,
    posLocal,
    textAnchors,
    dy,
    dx,
    y,
    x,
    labelsLocal,
    $scale,
    $axesHeight,
    $yLim,
    $axesWidth,
    $xLim
  });
  $$self.$inject_state = ($$props2) => {
    if ("xValues" in $$props2)
      $$invalidate(15, xValues = $$props2.xValues);
    if ("yValues" in $$props2)
      $$invalidate(16, yValues = $$props2.yValues);
    if ("labels" in $$props2)
      $$invalidate(17, labels = $$props2.labels);
    if ("pos" in $$props2)
      $$invalidate(0, pos = $$props2.pos);
    if ("faceColor" in $$props2)
      $$invalidate(18, faceColor = $$props2.faceColor);
    if ("borderColor" in $$props2)
      $$invalidate(19, borderColor = $$props2.borderColor);
    if ("borderWidth" in $$props2)
      $$invalidate(20, borderWidth = $$props2.borderWidth);
    if ("textSize" in $$props2)
      $$invalidate(21, textSize = $$props2.textSize);
    if ("style" in $$props2)
      $$invalidate(1, style = $$props2.style);
    if ("title" in $$props2)
      $$invalidate(2, title = $$props2.title);
    if ("textStyleStr" in $$props2)
      $$invalidate(3, textStyleStr = $$props2.textStyleStr);
    if ("posLocal" in $$props2)
      $$invalidate(22, posLocal = $$props2.posLocal);
    if ("textAnchors" in $$props2)
      $$invalidate(4, textAnchors = $$props2.textAnchors);
    if ("dy" in $$props2)
      $$invalidate(5, dy = $$props2.dy);
    if ("dx" in $$props2)
      $$invalidate(6, dx = $$props2.dx);
    if ("y" in $$props2)
      $$invalidate(7, y = $$props2.y);
    if ("x" in $$props2)
      $$invalidate(8, x = $$props2.x);
    if ("labelsLocal" in $$props2)
      $$invalidate(9, labelsLocal = $$props2.labelsLocal);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 163840) {
      $:
        $$invalidate(9, labelsLocal = processValues(labels, xValues.length));
    }
    if ($$self.$$.dirty[0] & 32769) {
      $:
        $$invalidate(22, posLocal = pos === 0 ? pos : processValues(pos, xValues.length));
    }
    if ($$self.$$.dirty[0] & 201359360) {
      $:
        $$invalidate(8, x = axes.scaleX(xValues, $xLim, $axesWidth));
    }
    if ($$self.$$.dirty[0] & 50397184) {
      $:
        $$invalidate(7, y = axes.scaleY(yValues, $yLim, $axesHeight));
    }
    if ($$self.$$.dirty[0] & 12582913) {
      $:
        $$invalidate(6, dx = pos === 0 ? 0 : subset(vmult([0, 1, 0, -1], axes.LABELS_MARGIN[$scale]), posLocal));
    }
    if ($$self.$$.dirty[0] & 12582913) {
      $:
        $$invalidate(5, dy = pos === 0 ? 0 : subset(vmult([1, 0, -1, 0], axes.LABELS_MARGIN[$scale]), posLocal));
    }
    if ($$self.$$.dirty[0] & 4194305) {
      $:
        $$invalidate(4, textAnchors = pos === 0 ? "middle" : subset(["middle", "start", "middle", "end"], posLocal));
    }
    if ($$self.$$.dirty[0] & 3932160) {
      $:
        $$invalidate(3, textStyleStr = `dominant-baseline:middle;fill:${faceColor};stroke-width:${borderWidth}px;stroke:${borderColor};
      font-size:${textSize}em; text-anchor:middle;`);
    }
  };
  return [
    pos,
    style,
    title,
    textStyleStr,
    textAnchors,
    dy,
    dx,
    y,
    x,
    labelsLocal,
    xLim,
    yLim,
    axesWidth,
    axesHeight,
    scale,
    xValues,
    yValues,
    labels,
    faceColor,
    borderColor,
    borderWidth,
    textSize,
    posLocal,
    $scale,
    $axesHeight,
    $yLim,
    $axesWidth,
    $xLim
  ];
}
var TextLabels = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance7,
      create_fragment7,
      safe_not_equal,
      {
        xValues: 15,
        yValues: 16,
        labels: 17,
        pos: 0,
        faceColor: 18,
        borderColor: 19,
        borderWidth: 20,
        textSize: 21,
        style: 1,
        title: 2
      },
      add_css7,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TextLabels",
      options,
      id: create_fragment7.name
    });
  }
  get xValues() {
    throw new Error("<TextLabels>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xValues(value) {
    throw new Error("<TextLabels>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yValues() {
    throw new Error("<TextLabels>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yValues(value) {
    throw new Error("<TextLabels>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labels() {
    throw new Error("<TextLabels>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labels(value) {
    throw new Error("<TextLabels>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pos() {
    throw new Error("<TextLabels>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pos(value) {
    throw new Error("<TextLabels>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get faceColor() {
    throw new Error("<TextLabels>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set faceColor(value) {
    throw new Error("<TextLabels>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderColor() {
    throw new Error("<TextLabels>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderColor(value) {
    throw new Error("<TextLabels>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderWidth() {
    throw new Error("<TextLabels>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderWidth(value) {
    throw new Error("<TextLabels>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get textSize() {
    throw new Error("<TextLabels>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set textSize(value) {
    throw new Error("<TextLabels>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<TextLabels>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<TextLabels>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<TextLabels>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<TextLabels>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TextLabels_default = TextLabels;

// node_modules/svelte-plots-basic/src/TextLegend.svelte
var file8 = "node_modules/svelte-plots-basic/src/TextLegend.svelte";
function get_each_context6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[22] = list[i];
  child_ctx[24] = i;
  return child_ctx;
}
function create_if_block8(ctx) {
  let text_1;
  let each_value = ctx[2];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block6(get_each_context6(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      text_1 = svg_element("text");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr_dev(text_1, "style", ctx[3]);
      attr_dev(text_1, "x", ctx[5]);
      attr_dev(text_1, "y", ctx[4]);
      attr_dev(text_1, "dx", ctx[0]);
      attr_dev(text_1, "dy", ctx[1]);
      attr_dev(text_1, "dominant-baseline", "middle");
      attr_dev(text_1, "text-anchor", "start");
      add_location(text_1, file8, 32, 3, 1039);
    },
    m: function mount(target, anchor) {
      insert_dev(target, text_1, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(text_1, null);
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & 39) {
        each_value = ctx2[2];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context6(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block6(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(text_1, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 8) {
        attr_dev(text_1, "style", ctx2[3]);
      }
      if (dirty & 32) {
        attr_dev(text_1, "x", ctx2[5]);
      }
      if (dirty & 16) {
        attr_dev(text_1, "y", ctx2[4]);
      }
      if (dirty & 1) {
        attr_dev(text_1, "dx", ctx2[0]);
      }
      if (dirty & 2) {
        attr_dev(text_1, "dy", ctx2[1]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(text_1);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block8.name,
    type: "if",
    source: "(32:0) {#if x !== undefined && y !== undefined && elements.length > 0}",
    ctx
  });
  return block;
}
function create_each_block6(ctx) {
  let tspan;
  let raw_value = ctx[22] + "";
  let tspan_dy_value;
  const block = {
    c: function create() {
      tspan = svg_element("tspan");
      attr_dev(tspan, "x", ctx[5]);
      attr_dev(tspan, "dx", ctx[0]);
      attr_dev(tspan, "dy", tspan_dy_value = ctx[24] === 0 ? 0 : ctx[1]);
      add_location(tspan, file8, 34, 9, 1183);
    },
    m: function mount(target, anchor) {
      insert_dev(target, tspan, anchor);
      tspan.innerHTML = raw_value;
    },
    p: function update(ctx2, dirty) {
      if (dirty & 4 && raw_value !== (raw_value = ctx2[22] + ""))
        tspan.innerHTML = raw_value;
      ;
      if (dirty & 32) {
        attr_dev(tspan, "x", ctx2[5]);
      }
      if (dirty & 1) {
        attr_dev(tspan, "dx", ctx2[0]);
      }
      if (dirty & 2 && tspan_dy_value !== (tspan_dy_value = ctx2[24] === 0 ? 0 : ctx2[1])) {
        attr_dev(tspan, "dy", tspan_dy_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(tspan);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block6.name,
    type: "each",
    source: "(34:6) {#each elements as el, i}",
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let if_block_anchor;
  let if_block = ctx[5] !== void 0 && ctx[4] !== void 0 && ctx[2].length > 0 && create_if_block8(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[5] !== void 0 && ctx2[4] !== void 0 && ctx2[2].length > 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block8(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  let x;
  let y;
  let textStyleStr;
  let $axesHeight;
  let $yLim;
  let $axesWidth;
  let $xLim;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TextLegend", slots, []);
  let { left } = $$props;
  let { top } = $$props;
  let { dx = "0" } = $$props;
  let { dy = "1.25em" } = $$props;
  let { elements } = $$props;
  let { faceColor = Colors.PRIMARY_TEXT } = $$props;
  let { borderColor = "transparent" } = $$props;
  let { borderWidth = 0 } = $$props;
  let { textSize = 1 } = $$props;
  const axes = getContext("axes");
  const xLim = axes.xLim;
  validate_store(xLim, "xLim");
  component_subscribe($$self, xLim, (value) => $$invalidate(19, $xLim = value));
  const yLim = axes.yLim;
  validate_store(yLim, "yLim");
  component_subscribe($$self, yLim, (value) => $$invalidate(17, $yLim = value));
  const axesWidth = axes.width;
  validate_store(axesWidth, "axesWidth");
  component_subscribe($$self, axesWidth, (value) => $$invalidate(18, $axesWidth = value));
  const axesHeight = axes.height;
  validate_store(axesHeight, "axesHeight");
  component_subscribe($$self, axesHeight, (value) => $$invalidate(16, $axesHeight = value));
  const scale = axes.scale;
  $$self.$$.on_mount.push(function() {
    if (left === void 0 && !("left" in $$props || $$self.$$.bound[$$self.$$.props["left"]])) {
      console.warn("<TextLegend> was created without expected prop 'left'");
    }
    if (top === void 0 && !("top" in $$props || $$self.$$.bound[$$self.$$.props["top"]])) {
      console.warn("<TextLegend> was created without expected prop 'top'");
    }
    if (elements === void 0 && !("elements" in $$props || $$self.$$.bound[$$self.$$.props["elements"]])) {
      console.warn("<TextLegend> was created without expected prop 'elements'");
    }
  });
  const writable_props = [
    "left",
    "top",
    "dx",
    "dy",
    "elements",
    "faceColor",
    "borderColor",
    "borderWidth",
    "textSize"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TextLegend> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("left" in $$props2)
      $$invalidate(10, left = $$props2.left);
    if ("top" in $$props2)
      $$invalidate(11, top = $$props2.top);
    if ("dx" in $$props2)
      $$invalidate(0, dx = $$props2.dx);
    if ("dy" in $$props2)
      $$invalidate(1, dy = $$props2.dy);
    if ("elements" in $$props2)
      $$invalidate(2, elements = $$props2.elements);
    if ("faceColor" in $$props2)
      $$invalidate(12, faceColor = $$props2.faceColor);
    if ("borderColor" in $$props2)
      $$invalidate(13, borderColor = $$props2.borderColor);
    if ("borderWidth" in $$props2)
      $$invalidate(14, borderWidth = $$props2.borderWidth);
    if ("textSize" in $$props2)
      $$invalidate(15, textSize = $$props2.textSize);
  };
  $$self.$capture_state = () => ({
    getContext,
    Colors,
    left,
    top,
    dx,
    dy,
    elements,
    faceColor,
    borderColor,
    borderWidth,
    textSize,
    axes,
    xLim,
    yLim,
    axesWidth,
    axesHeight,
    scale,
    textStyleStr,
    y,
    x,
    $axesHeight,
    $yLim,
    $axesWidth,
    $xLim
  });
  $$self.$inject_state = ($$props2) => {
    if ("left" in $$props2)
      $$invalidate(10, left = $$props2.left);
    if ("top" in $$props2)
      $$invalidate(11, top = $$props2.top);
    if ("dx" in $$props2)
      $$invalidate(0, dx = $$props2.dx);
    if ("dy" in $$props2)
      $$invalidate(1, dy = $$props2.dy);
    if ("elements" in $$props2)
      $$invalidate(2, elements = $$props2.elements);
    if ("faceColor" in $$props2)
      $$invalidate(12, faceColor = $$props2.faceColor);
    if ("borderColor" in $$props2)
      $$invalidate(13, borderColor = $$props2.borderColor);
    if ("borderWidth" in $$props2)
      $$invalidate(14, borderWidth = $$props2.borderWidth);
    if ("textSize" in $$props2)
      $$invalidate(15, textSize = $$props2.textSize);
    if ("textStyleStr" in $$props2)
      $$invalidate(3, textStyleStr = $$props2.textStyleStr);
    if ("y" in $$props2)
      $$invalidate(4, y = $$props2.y);
    if ("x" in $$props2)
      $$invalidate(5, x = $$props2.x);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 787456) {
      $:
        $$invalidate(5, x = axes.scaleX([left], $xLim, $axesWidth));
    }
    if ($$self.$$.dirty & 198656) {
      $:
        $$invalidate(4, y = axes.scaleY([top], $yLim, $axesHeight));
    }
    if ($$self.$$.dirty & 61440) {
      $:
        $$invalidate(3, textStyleStr = `fill:${faceColor};stroke-width:${borderWidth}px;stroke:${borderColor};font-size:${textSize}em;`);
    }
  };
  return [
    dx,
    dy,
    elements,
    textStyleStr,
    y,
    x,
    xLim,
    yLim,
    axesWidth,
    axesHeight,
    left,
    top,
    faceColor,
    borderColor,
    borderWidth,
    textSize,
    $axesHeight,
    $yLim,
    $axesWidth,
    $xLim
  ];
}
var TextLegend = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, {
      left: 10,
      top: 11,
      dx: 0,
      dy: 1,
      elements: 2,
      faceColor: 12,
      borderColor: 13,
      borderWidth: 14,
      textSize: 15
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TextLegend",
      options,
      id: create_fragment8.name
    });
  }
  get left() {
    throw new Error("<TextLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set left(value) {
    throw new Error("<TextLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get top() {
    throw new Error("<TextLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set top(value) {
    throw new Error("<TextLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dx() {
    throw new Error("<TextLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dx(value) {
    throw new Error("<TextLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dy() {
    throw new Error("<TextLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dy(value) {
    throw new Error("<TextLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get elements() {
    throw new Error("<TextLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set elements(value) {
    throw new Error("<TextLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get faceColor() {
    throw new Error("<TextLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set faceColor(value) {
    throw new Error("<TextLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderColor() {
    throw new Error("<TextLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderColor(value) {
    throw new Error("<TextLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderWidth() {
    throw new Error("<TextLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderWidth(value) {
    throw new Error("<TextLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get textSize() {
    throw new Error("<TextLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set textSize(value) {
    throw new Error("<TextLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TextLegend_default = TextLegend;

// node_modules/svelte-plots-basic/src/BarSeries.svelte
function create_fragment9(ctx) {
  let rectangles;
  let current;
  rectangles = new Rectangles_default({
    props: {
      style: "series_bar",
      left: ctx[4],
      top: ctx[5],
      width: ctx[3],
      height: ctx[6],
      borderColor: ctx[2],
      faceColor: ctx[1],
      title: ctx[0]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(rectangles.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(rectangles, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const rectangles_changes = {};
      if (dirty & 16)
        rectangles_changes.left = ctx2[4];
      if (dirty & 32)
        rectangles_changes.top = ctx2[5];
      if (dirty & 8)
        rectangles_changes.width = ctx2[3];
      if (dirty & 64)
        rectangles_changes.height = ctx2[6];
      if (dirty & 4)
        rectangles_changes.borderColor = ctx2[2];
      if (dirty & 2)
        rectangles_changes.faceColor = ctx2[1];
      if (dirty & 1)
        rectangles_changes.title = ctx2[0];
      rectangles.$set(rectangles_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(rectangles.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(rectangles.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(rectangles, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BarSeries", slots, []);
  let { xValues } = $$props;
  let { yValues } = $$props;
  let { barWidth = 0.8 } = $$props;
  let { title = "" } = $$props;
  let { faceColor = Colors.PRIMARY } = $$props;
  let { borderColor = Colors.PRIMARY } = $$props;
  let { showLabels = "no" } = $$props;
  let width;
  let left;
  let top;
  let height;
  const axes = getContext("axes");
  $$self.$$.on_mount.push(function() {
    if (xValues === void 0 && !("xValues" in $$props || $$self.$$.bound[$$self.$$.props["xValues"]])) {
      console.warn("<BarSeries> was created without expected prop 'xValues'");
    }
    if (yValues === void 0 && !("yValues" in $$props || $$self.$$.bound[$$self.$$.props["yValues"]])) {
      console.warn("<BarSeries> was created without expected prop 'yValues'");
    }
  });
  const writable_props = [
    "xValues",
    "yValues",
    "barWidth",
    "title",
    "faceColor",
    "borderColor",
    "showLabels"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<BarSeries> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("xValues" in $$props2)
      $$invalidate(7, xValues = $$props2.xValues);
    if ("yValues" in $$props2)
      $$invalidate(8, yValues = $$props2.yValues);
    if ("barWidth" in $$props2)
      $$invalidate(9, barWidth = $$props2.barWidth);
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("faceColor" in $$props2)
      $$invalidate(1, faceColor = $$props2.faceColor);
    if ("borderColor" in $$props2)
      $$invalidate(2, borderColor = $$props2.borderColor);
    if ("showLabels" in $$props2)
      $$invalidate(10, showLabels = $$props2.showLabels);
  };
  $$self.$capture_state = () => ({
    getContext,
    Colors,
    max,
    mrange,
    diff,
    Rectangles: Rectangles_default,
    xValues,
    yValues,
    barWidth,
    title,
    faceColor,
    borderColor,
    showLabels,
    width,
    left,
    top,
    height,
    axes
  });
  $$self.$inject_state = ($$props2) => {
    if ("xValues" in $$props2)
      $$invalidate(7, xValues = $$props2.xValues);
    if ("yValues" in $$props2)
      $$invalidate(8, yValues = $$props2.yValues);
    if ("barWidth" in $$props2)
      $$invalidate(9, barWidth = $$props2.barWidth);
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("faceColor" in $$props2)
      $$invalidate(1, faceColor = $$props2.faceColor);
    if ("borderColor" in $$props2)
      $$invalidate(2, borderColor = $$props2.borderColor);
    if ("showLabels" in $$props2)
      $$invalidate(10, showLabels = $$props2.showLabels);
    if ("width" in $$props2)
      $$invalidate(3, width = $$props2.width);
    if ("left" in $$props2)
      $$invalidate(4, left = $$props2.left);
    if ("top" in $$props2)
      $$invalidate(5, top = $$props2.top);
    if ("height" in $$props2)
      $$invalidate(6, height = $$props2.height);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 648) {
      $: {
        if (!Array.isArray(xValues)) {
          throw "BarSeries: parameter 'xValues' must be a numeric vector.";
        }
        if (barWidth <= 0 || barWidth > 1) {
          throw "BarSeries: parameters 'barWidth' should be between 0 and 1.";
        }
        const xValuesRange = mrange(xValues, 0.1);
        xValuesRange[0] = xValuesRange[0] - barWidth * diff(xValuesRange) / xValues.length * 0.5;
        xValuesRange[1] = xValuesRange[1] + barWidth * diff(xValuesRange) / xValues.length * 0.5;
        axes.adjustXAxisLimits(xValuesRange);
        $$invalidate(3, width = Array(xValues.length).fill(max(diff(xValues)) * barWidth));
        $$invalidate(4, left = xValues.map((v, i) => v - width[i] / 2));
      }
    }
    if ($$self.$$.dirty & 1408) {
      $: {
        if (!Array.isArray(yValues) || xValues.length != yValues.length) {
          throw "BarSeries: parameter 'yValues' must be a numeric vector of the same length as 'xValues'.";
        }
        const yValuesRange = mrange(yValues, showLabels === "no" ? 0.05 : 0.2);
        axes.adjustYAxisLimits(yValuesRange);
        $$invalidate(5, top = yValues.map((v) => v > 0 ? v : 0));
        $$invalidate(6, height = yValues.map((v) => Math.abs(v)));
      }
    }
  };
  return [
    title,
    faceColor,
    borderColor,
    width,
    left,
    top,
    height,
    xValues,
    yValues,
    barWidth,
    showLabels
  ];
}
var BarSeries = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, {
      xValues: 7,
      yValues: 8,
      barWidth: 9,
      title: 0,
      faceColor: 1,
      borderColor: 2,
      showLabels: 10
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BarSeries",
      options,
      id: create_fragment9.name
    });
  }
  get xValues() {
    throw new Error("<BarSeries>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xValues(value) {
    throw new Error("<BarSeries>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yValues() {
    throw new Error("<BarSeries>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yValues(value) {
    throw new Error("<BarSeries>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get barWidth() {
    throw new Error("<BarSeries>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set barWidth(value) {
    throw new Error("<BarSeries>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<BarSeries>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<BarSeries>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get faceColor() {
    throw new Error("<BarSeries>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set faceColor(value) {
    throw new Error("<BarSeries>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderColor() {
    throw new Error("<BarSeries>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderColor(value) {
    throw new Error("<BarSeries>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showLabels() {
    throw new Error("<BarSeries>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showLabels(value) {
    throw new Error("<BarSeries>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BarSeries_default = BarSeries;

// node_modules/svelte-plots-basic/src/ScatterSeries.svelte
function create_fragment10(ctx) {
  let textlabels;
  let current;
  textlabels = new TextLabels_default({
    props: {
      xValues: ctx[0],
      yValues: ctx[1],
      faceColor: ctx[3],
      borderColor: ctx[4],
      borderWidth: ctx[5],
      title: ctx[2],
      style: "series_scatter",
      labels: ctx[7],
      textSize: ctx[6]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(textlabels.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(textlabels, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const textlabels_changes = {};
      if (dirty & 1)
        textlabels_changes.xValues = ctx2[0];
      if (dirty & 2)
        textlabels_changes.yValues = ctx2[1];
      if (dirty & 8)
        textlabels_changes.faceColor = ctx2[3];
      if (dirty & 16)
        textlabels_changes.borderColor = ctx2[4];
      if (dirty & 32)
        textlabels_changes.borderWidth = ctx2[5];
      if (dirty & 4)
        textlabels_changes.title = ctx2[2];
      if (dirty & 128)
        textlabels_changes.labels = ctx2[7];
      if (dirty & 64)
        textlabels_changes.textSize = ctx2[6];
      textlabels.$set(textlabels_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(textlabels.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(textlabels.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(textlabels, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ScatterSeries", slots, []);
  let { xValues } = $$props;
  let { yValues } = $$props;
  let { marker = 1 } = $$props;
  let { title = "" } = $$props;
  let { faceColor = "transparent" } = $$props;
  let { borderColor = Colors.PRIMARY } = $$props;
  let { borderWidth = 1 } = $$props;
  let { markerSize = 1 } = $$props;
  const markers = ["\u25CF", "\u25FC", "\u25B2", "\u25BC", "\u2B25", "+", "*", "\u2A2F"];
  let markerSymbol;
  if (typeof marker !== "number" || marker < 1 || marker > markers.length) {
    throw `ScatterSeries: parameter 'marker' must be a number from 1 to ${markers.length}."`;
  }
  const axes = getContext("axes");
  $$self.$$.on_mount.push(function() {
    if (xValues === void 0 && !("xValues" in $$props || $$self.$$.bound[$$self.$$.props["xValues"]])) {
      console.warn("<ScatterSeries> was created without expected prop 'xValues'");
    }
    if (yValues === void 0 && !("yValues" in $$props || $$self.$$.bound[$$self.$$.props["yValues"]])) {
      console.warn("<ScatterSeries> was created without expected prop 'yValues'");
    }
  });
  const writable_props = [
    "xValues",
    "yValues",
    "marker",
    "title",
    "faceColor",
    "borderColor",
    "borderWidth",
    "markerSize"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ScatterSeries> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("xValues" in $$props2)
      $$invalidate(0, xValues = $$props2.xValues);
    if ("yValues" in $$props2)
      $$invalidate(1, yValues = $$props2.yValues);
    if ("marker" in $$props2)
      $$invalidate(8, marker = $$props2.marker);
    if ("title" in $$props2)
      $$invalidate(2, title = $$props2.title);
    if ("faceColor" in $$props2)
      $$invalidate(3, faceColor = $$props2.faceColor);
    if ("borderColor" in $$props2)
      $$invalidate(4, borderColor = $$props2.borderColor);
    if ("borderWidth" in $$props2)
      $$invalidate(5, borderWidth = $$props2.borderWidth);
    if ("markerSize" in $$props2)
      $$invalidate(6, markerSize = $$props2.markerSize);
  };
  $$self.$capture_state = () => ({
    getContext,
    mrange,
    Colors,
    TextLabels: TextLabels_default,
    xValues,
    yValues,
    marker,
    title,
    faceColor,
    borderColor,
    borderWidth,
    markerSize,
    markers,
    markerSymbol,
    axes
  });
  $$self.$inject_state = ($$props2) => {
    if ("xValues" in $$props2)
      $$invalidate(0, xValues = $$props2.xValues);
    if ("yValues" in $$props2)
      $$invalidate(1, yValues = $$props2.yValues);
    if ("marker" in $$props2)
      $$invalidate(8, marker = $$props2.marker);
    if ("title" in $$props2)
      $$invalidate(2, title = $$props2.title);
    if ("faceColor" in $$props2)
      $$invalidate(3, faceColor = $$props2.faceColor);
    if ("borderColor" in $$props2)
      $$invalidate(4, borderColor = $$props2.borderColor);
    if ("borderWidth" in $$props2)
      $$invalidate(5, borderWidth = $$props2.borderWidth);
    if ("markerSize" in $$props2)
      $$invalidate(6, markerSize = $$props2.markerSize);
    if ("markerSymbol" in $$props2)
      $$invalidate(7, markerSymbol = $$props2.markerSymbol);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 257) {
      $: {
        if (!Array.isArray(xValues)) {
          throw "ScatterSeries: parameter 'xValues' must be a numeric vector.";
        }
        const xValuesRange = mrange(xValues, 0.05);
        axes.adjustXAxisLimits(xValuesRange);
        $$invalidate(7, markerSymbol = "");
        $$invalidate(7, markerSymbol = markers[marker - 1]);
      }
    }
    if ($$self.$$.dirty & 3) {
      $: {
        if (!Array.isArray(yValues) || xValues.length != yValues.length) {
          throw "BarSeries: parameter 'yValues' must be a numeric vector of the same length as 'xValues'.";
        }
        const yValuesRange = mrange(yValues, 0.05);
        axes.adjustYAxisLimits(yValuesRange);
      }
    }
  };
  return [
    xValues,
    yValues,
    title,
    faceColor,
    borderColor,
    borderWidth,
    markerSize,
    markerSymbol,
    marker
  ];
}
var ScatterSeries = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, {
      xValues: 0,
      yValues: 1,
      marker: 8,
      title: 2,
      faceColor: 3,
      borderColor: 4,
      borderWidth: 5,
      markerSize: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ScatterSeries",
      options,
      id: create_fragment10.name
    });
  }
  get xValues() {
    throw new Error("<ScatterSeries>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xValues(value) {
    throw new Error("<ScatterSeries>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yValues() {
    throw new Error("<ScatterSeries>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yValues(value) {
    throw new Error("<ScatterSeries>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get marker() {
    throw new Error("<ScatterSeries>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set marker(value) {
    throw new Error("<ScatterSeries>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<ScatterSeries>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<ScatterSeries>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get faceColor() {
    throw new Error("<ScatterSeries>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set faceColor(value) {
    throw new Error("<ScatterSeries>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderColor() {
    throw new Error("<ScatterSeries>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderColor(value) {
    throw new Error("<ScatterSeries>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderWidth() {
    throw new Error("<ScatterSeries>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderWidth(value) {
    throw new Error("<ScatterSeries>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerSize() {
    throw new Error("<ScatterSeries>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerSize(value) {
    throw new Error("<ScatterSeries>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ScatterSeries_default = ScatterSeries;

// node_modules/svelte-plots-basic/src/LineSeries.svelte
var file9 = "node_modules/svelte-plots-basic/src/LineSeries.svelte";
function add_css8(target) {
  append_styles(target, "svelte-1qspqf3", ".svelte-1qspqf3{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTGluZVNlcmllcy5zdmVsdGUiLCJtYXBwaW5ncyI6ImlCQWlEQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJMaW5lU2VyaWVzLnN2ZWx0ZSJdfQ== */");
}
function create_if_block9(ctx) {
  let g;
  let polyline;
  const block = {
    c: function create() {
      g = svg_element("g");
      polyline = svg_element("polyline");
      attr_dev(polyline, "class", "line svelte-1qspqf3");
      attr_dev(polyline, "points", ctx[2]);
      add_location(polyline, file9, 44, 6, 1622);
      attr_dev(g, "class", "series series_line svelte-1qspqf3");
      attr_dev(g, "style", ctx[1]);
      attr_dev(g, "title", ctx[0]);
      add_location(g, file9, 43, 3, 1550);
    },
    m: function mount(target, anchor) {
      insert_dev(target, g, anchor);
      append_dev(g, polyline);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 4) {
        attr_dev(polyline, "points", ctx2[2]);
      }
      if (dirty & 2) {
        attr_dev(g, "style", ctx2[1]);
      }
      if (dirty & 1) {
        attr_dev(g, "title", ctx2[0]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(g);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block9.name,
    type: "if",
    source: "(43:0) {#if p !== undefined}",
    ctx
  });
  return block;
}
function create_fragment11(ctx) {
  let if_block_anchor;
  let if_block = ctx[2] !== void 0 && create_if_block9(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[2] !== void 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block9(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  let x;
  let y;
  let p;
  let lineStyleStr;
  let $scale;
  let $axesHeight;
  let $yLim;
  let $axesWidth;
  let $xLim;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LineSeries", slots, []);
  let { xValues } = $$props;
  let { yValues } = $$props;
  let { title = "" } = $$props;
  let { lineWidth = 1 } = $$props;
  let { lineColor = Colors.PRIMARY } = $$props;
  let { lineType = 1 } = $$props;
  if (!Array.isArray(xValues) || !Array.isArray(yValues) || xValues.length != yValues.length) {
    throw "LineSeries: parameters 'xValues' and 'yValues' must be numeric vectors of the same length.";
  }
  const xValuesRange = mrange(xValues, 0.05);
  const yValuesRange = mrange(yValues, 0.05);
  const axes = getContext("axes");
  axes.adjustXAxisLimits(xValuesRange);
  axes.adjustYAxisLimits(yValuesRange);
  const xLim = axes.xLim;
  validate_store(xLim, "xLim");
  component_subscribe($$self, xLim, (value) => $$invalidate(19, $xLim = value));
  const yLim = axes.yLim;
  validate_store(yLim, "yLim");
  component_subscribe($$self, yLim, (value) => $$invalidate(17, $yLim = value));
  const axesWidth = axes.width;
  validate_store(axesWidth, "axesWidth");
  component_subscribe($$self, axesWidth, (value) => $$invalidate(18, $axesWidth = value));
  const axesHeight = axes.height;
  validate_store(axesHeight, "axesHeight");
  component_subscribe($$self, axesHeight, (value) => $$invalidate(16, $axesHeight = value));
  const scale = axes.scale;
  validate_store(scale, "scale");
  component_subscribe($$self, scale, (value) => $$invalidate(15, $scale = value));
  $$self.$$.on_mount.push(function() {
    if (xValues === void 0 && !("xValues" in $$props || $$self.$$.bound[$$self.$$.props["xValues"]])) {
      console.warn("<LineSeries> was created without expected prop 'xValues'");
    }
    if (yValues === void 0 && !("yValues" in $$props || $$self.$$.bound[$$self.$$.props["yValues"]])) {
      console.warn("<LineSeries> was created without expected prop 'yValues'");
    }
  });
  const writable_props = ["xValues", "yValues", "title", "lineWidth", "lineColor", "lineType"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<LineSeries> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("xValues" in $$props2)
      $$invalidate(8, xValues = $$props2.xValues);
    if ("yValues" in $$props2)
      $$invalidate(9, yValues = $$props2.yValues);
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("lineWidth" in $$props2)
      $$invalidate(10, lineWidth = $$props2.lineWidth);
    if ("lineColor" in $$props2)
      $$invalidate(11, lineColor = $$props2.lineColor);
    if ("lineType" in $$props2)
      $$invalidate(12, lineType = $$props2.lineType);
  };
  $$self.$capture_state = () => ({
    getContext,
    mrange,
    Colors,
    xValues,
    yValues,
    title,
    lineWidth,
    lineColor,
    lineType,
    xValuesRange,
    yValuesRange,
    axes,
    xLim,
    yLim,
    axesWidth,
    axesHeight,
    scale,
    lineStyleStr,
    y,
    x,
    p,
    $scale,
    $axesHeight,
    $yLim,
    $axesWidth,
    $xLim
  });
  $$self.$inject_state = ($$props2) => {
    if ("xValues" in $$props2)
      $$invalidate(8, xValues = $$props2.xValues);
    if ("yValues" in $$props2)
      $$invalidate(9, yValues = $$props2.yValues);
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("lineWidth" in $$props2)
      $$invalidate(10, lineWidth = $$props2.lineWidth);
    if ("lineColor" in $$props2)
      $$invalidate(11, lineColor = $$props2.lineColor);
    if ("lineType" in $$props2)
      $$invalidate(12, lineType = $$props2.lineType);
    if ("lineStyleStr" in $$props2)
      $$invalidate(1, lineStyleStr = $$props2.lineStyleStr);
    if ("y" in $$props2)
      $$invalidate(13, y = $$props2.y);
    if ("x" in $$props2)
      $$invalidate(14, x = $$props2.x);
    if ("p" in $$props2)
      $$invalidate(2, p = $$props2.p);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 786688) {
      $:
        $$invalidate(14, x = axes.scaleX(xValues, $xLim, $axesWidth));
    }
    if ($$self.$$.dirty & 197120) {
      $:
        $$invalidate(13, y = axes.scaleY(yValues, $yLim, $axesHeight));
    }
    if ($$self.$$.dirty & 24576) {
      $:
        $$invalidate(2, p = x !== void 0 && y !== void 0 ? x.map((v, i) => `${v},${y[i]}`).join(" ") : void 0);
    }
    if ($$self.$$.dirty & 39936) {
      $:
        $$invalidate(1, lineStyleStr = `fill:transparent;stroke:${lineColor};stroke-width: ${lineWidth}px;
      stroke-dasharray:${axes.LINE_STYLES[$scale][lineType - 1]}`);
    }
  };
  return [
    title,
    lineStyleStr,
    p,
    xLim,
    yLim,
    axesWidth,
    axesHeight,
    scale,
    xValues,
    yValues,
    lineWidth,
    lineColor,
    lineType,
    y,
    x,
    $scale,
    $axesHeight,
    $yLim,
    $axesWidth,
    $xLim
  ];
}
var LineSeries = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance11,
      create_fragment11,
      safe_not_equal,
      {
        xValues: 8,
        yValues: 9,
        title: 0,
        lineWidth: 10,
        lineColor: 11,
        lineType: 12
      },
      add_css8
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LineSeries",
      options,
      id: create_fragment11.name
    });
  }
  get xValues() {
    throw new Error("<LineSeries>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xValues(value) {
    throw new Error("<LineSeries>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yValues() {
    throw new Error("<LineSeries>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yValues(value) {
    throw new Error("<LineSeries>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<LineSeries>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<LineSeries>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineWidth() {
    throw new Error("<LineSeries>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineWidth(value) {
    throw new Error("<LineSeries>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineColor() {
    throw new Error("<LineSeries>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineColor(value) {
    throw new Error("<LineSeries>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineType() {
    throw new Error("<LineSeries>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineType(value) {
    throw new Error("<LineSeries>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LineSeries_default = LineSeries;

// node_modules/svelte-plots-basic/src/AreaSeries.svelte
var file10 = "node_modules/svelte-plots-basic/src/AreaSeries.svelte";
function add_css9(target) {
  append_styles(target, "svelte-1qspqf3", ".svelte-1qspqf3{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQXJlYVNlcmllcy5zdmVsdGUiLCJtYXBwaW5ncyI6ImlCQW9EQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJBcmVhU2VyaWVzLnN2ZWx0ZSJdfQ== */");
}
function create_if_block10(ctx) {
  let g;
  let polygon;
  let polygon_points_value;
  const block = {
    c: function create() {
      g = svg_element("g");
      polygon = svg_element("polygon");
      attr_dev(polygon, "points", polygon_points_value = ctx[1][0] + "," + ctx[4] + " " + ctx[3] + " " + ctx[1][ctx[1].length - 1] + "," + ctx[4][0]);
      attr_dev(polygon, "class", "svelte-1qspqf3");
      add_location(polygon, file10, 47, 3, 1754);
      attr_dev(g, "class", "series lineseries svelte-1qspqf3");
      attr_dev(g, "style", ctx[2]);
      attr_dev(g, "title", ctx[0]);
      add_location(g, file10, 46, 3, 1682);
    },
    m: function mount(target, anchor) {
      insert_dev(target, g, anchor);
      append_dev(g, polygon);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 26 && polygon_points_value !== (polygon_points_value = ctx2[1][0] + "," + ctx2[4] + " " + ctx2[3] + " " + ctx2[1][ctx2[1].length - 1] + "," + ctx2[4][0])) {
        attr_dev(polygon, "points", polygon_points_value);
      }
      if (dirty & 4) {
        attr_dev(g, "style", ctx2[2]);
      }
      if (dirty & 1) {
        attr_dev(g, "title", ctx2[0]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(g);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block10.name,
    type: "if",
    source: "(46:0) {#if p !== undefined}",
    ctx
  });
  return block;
}
function create_fragment12(ctx) {
  let if_block_anchor;
  let if_block = ctx[3] !== void 0 && create_if_block10(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[3] !== void 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block10(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance12($$self, $$props, $$invalidate) {
  let y0;
  let x;
  let y;
  let p;
  let areaStyleStr;
  let $scale;
  let $axesHeight;
  let $yLim;
  let $axesWidth;
  let $xLim;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AreaSeries", slots, []);
  let { xValues } = $$props;
  let { yValues } = $$props;
  let { title = "" } = $$props;
  let { lineWidth = 1 } = $$props;
  let { lineColor = Colors.PRIMARY } = $$props;
  let { fillColor = Colors.PRIMARY } = $$props;
  let { opacity = 1 } = $$props;
  let { lineType = 1 } = $$props;
  if (!Array.isArray(xValues) || !Array.isArray(yValues) || xValues.length != yValues.length) {
    throw "AreaSeries: parameters 'xValues' and 'yValues' must be numeric vectors of the same length.";
  }
  const xValuesRange = mrange(xValues, 0.05);
  const yValuesRange = mrange(yValues, 0.05);
  const axes = getContext("axes");
  axes.adjustXAxisLimits(xValuesRange);
  axes.adjustYAxisLimits(yValuesRange);
  const xLim = axes.xLim;
  validate_store(xLim, "xLim");
  component_subscribe($$self, xLim, (value) => $$invalidate(22, $xLim = value));
  const yLim = axes.yLim;
  validate_store(yLim, "yLim");
  component_subscribe($$self, yLim, (value) => $$invalidate(20, $yLim = value));
  const axesWidth = axes.width;
  validate_store(axesWidth, "axesWidth");
  component_subscribe($$self, axesWidth, (value) => $$invalidate(21, $axesWidth = value));
  const axesHeight = axes.height;
  validate_store(axesHeight, "axesHeight");
  component_subscribe($$self, axesHeight, (value) => $$invalidate(19, $axesHeight = value));
  const scale = axes.scale;
  validate_store(scale, "scale");
  component_subscribe($$self, scale, (value) => $$invalidate(18, $scale = value));
  $$self.$$.on_mount.push(function() {
    if (xValues === void 0 && !("xValues" in $$props || $$self.$$.bound[$$self.$$.props["xValues"]])) {
      console.warn("<AreaSeries> was created without expected prop 'xValues'");
    }
    if (yValues === void 0 && !("yValues" in $$props || $$self.$$.bound[$$self.$$.props["yValues"]])) {
      console.warn("<AreaSeries> was created without expected prop 'yValues'");
    }
  });
  const writable_props = [
    "xValues",
    "yValues",
    "title",
    "lineWidth",
    "lineColor",
    "fillColor",
    "opacity",
    "lineType"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<AreaSeries> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("xValues" in $$props2)
      $$invalidate(10, xValues = $$props2.xValues);
    if ("yValues" in $$props2)
      $$invalidate(11, yValues = $$props2.yValues);
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("lineWidth" in $$props2)
      $$invalidate(12, lineWidth = $$props2.lineWidth);
    if ("lineColor" in $$props2)
      $$invalidate(13, lineColor = $$props2.lineColor);
    if ("fillColor" in $$props2)
      $$invalidate(14, fillColor = $$props2.fillColor);
    if ("opacity" in $$props2)
      $$invalidate(15, opacity = $$props2.opacity);
    if ("lineType" in $$props2)
      $$invalidate(16, lineType = $$props2.lineType);
  };
  $$self.$capture_state = () => ({
    getContext,
    mrange,
    Colors,
    xValues,
    yValues,
    title,
    lineWidth,
    lineColor,
    fillColor,
    opacity,
    lineType,
    xValuesRange,
    yValuesRange,
    axes,
    xLim,
    yLim,
    axesWidth,
    axesHeight,
    scale,
    areaStyleStr,
    y,
    x,
    p,
    y0,
    $scale,
    $axesHeight,
    $yLim,
    $axesWidth,
    $xLim
  });
  $$self.$inject_state = ($$props2) => {
    if ("xValues" in $$props2)
      $$invalidate(10, xValues = $$props2.xValues);
    if ("yValues" in $$props2)
      $$invalidate(11, yValues = $$props2.yValues);
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("lineWidth" in $$props2)
      $$invalidate(12, lineWidth = $$props2.lineWidth);
    if ("lineColor" in $$props2)
      $$invalidate(13, lineColor = $$props2.lineColor);
    if ("fillColor" in $$props2)
      $$invalidate(14, fillColor = $$props2.fillColor);
    if ("opacity" in $$props2)
      $$invalidate(15, opacity = $$props2.opacity);
    if ("lineType" in $$props2)
      $$invalidate(16, lineType = $$props2.lineType);
    if ("areaStyleStr" in $$props2)
      $$invalidate(2, areaStyleStr = $$props2.areaStyleStr);
    if ("y" in $$props2)
      $$invalidate(17, y = $$props2.y);
    if ("x" in $$props2)
      $$invalidate(1, x = $$props2.x);
    if ("p" in $$props2)
      $$invalidate(3, p = $$props2.p);
    if ("y0" in $$props2)
      $$invalidate(4, y0 = $$props2.y0);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1572864) {
      $:
        $$invalidate(4, y0 = axes.scaleY([0], $yLim, $axesHeight));
    }
    if ($$self.$$.dirty & 6292480) {
      $:
        $$invalidate(1, x = axes.scaleX(xValues, $xLim, $axesWidth));
    }
    if ($$self.$$.dirty & 1574912) {
      $:
        $$invalidate(17, y = axes.scaleY(yValues, $yLim, $axesHeight));
    }
    if ($$self.$$.dirty & 131074) {
      $:
        $$invalidate(3, p = x !== void 0 && y !== void 0 ? x.map((v, i) => `${v},${y[i]}`).join(" ") : void 0);
    }
    if ($$self.$$.dirty & 389120) {
      $:
        $$invalidate(2, areaStyleStr = `opacity:${opacity};fill:${fillColor};stroke:${lineColor};stroke-width: ${lineWidth}px;stroke-dasharray:${axes.LINE_STYLES[$scale][lineType - 1]}`);
    }
  };
  return [
    title,
    x,
    areaStyleStr,
    p,
    y0,
    xLim,
    yLim,
    axesWidth,
    axesHeight,
    scale,
    xValues,
    yValues,
    lineWidth,
    lineColor,
    fillColor,
    opacity,
    lineType,
    y,
    $scale,
    $axesHeight,
    $yLim,
    $axesWidth,
    $xLim
  ];
}
var AreaSeries = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance12,
      create_fragment12,
      safe_not_equal,
      {
        xValues: 10,
        yValues: 11,
        title: 0,
        lineWidth: 12,
        lineColor: 13,
        fillColor: 14,
        opacity: 15,
        lineType: 16
      },
      add_css9
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AreaSeries",
      options,
      id: create_fragment12.name
    });
  }
  get xValues() {
    throw new Error("<AreaSeries>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xValues(value) {
    throw new Error("<AreaSeries>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yValues() {
    throw new Error("<AreaSeries>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yValues(value) {
    throw new Error("<AreaSeries>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<AreaSeries>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<AreaSeries>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineWidth() {
    throw new Error("<AreaSeries>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineWidth(value) {
    throw new Error("<AreaSeries>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineColor() {
    throw new Error("<AreaSeries>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineColor(value) {
    throw new Error("<AreaSeries>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fillColor() {
    throw new Error("<AreaSeries>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fillColor(value) {
    throw new Error("<AreaSeries>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opacity() {
    throw new Error("<AreaSeries>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opacity(value) {
    throw new Error("<AreaSeries>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineType() {
    throw new Error("<AreaSeries>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineType(value) {
    throw new Error("<AreaSeries>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AreaSeries_default = AreaSeries;
export {
  AreaSeries_default as AreaSeries,
  Axes_default as Axes,
  BarSeries_default as BarSeries,
  Box_default as Box,
  Colors,
  LineSeries_default as LineSeries,
  Rectangles_default as Rectangles,
  ScatterSeries_default as ScatterSeries,
  Segments_default as Segments,
  TextLabels_default as TextLabels,
  TextLegend_default as TextLegend,
  XAxis_default as XAxis,
  YAxis_default as YAxis
};
//# sourceMappingURL=svelte-plots-basic.js.map
